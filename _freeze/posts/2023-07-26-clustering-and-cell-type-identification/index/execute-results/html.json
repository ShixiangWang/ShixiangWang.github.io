{
  "hash": "217a53cbbf085c1b7ea0f38fecd0b5d3",
  "result": {
    "markdown": "---\ntitle: Single-cell Workshop 2021 - 02 - 聚类和细胞类型鉴定\nauthor: Shixiang Wang\ndate: 2023-07-26\ncategories: [note,scRNA-seq,R]\ndraft: false\ndescription: ''\n\ntoc: true\n\nformat:\n  html:\n    code-fold: false\n    code-overflow: wrap\n    code-tools: false\n---\n\n\n学习资料：[GitHub 地址](https://github.com/pkuerten/single_cell_clustering_annotation.github.io/blob/main/index.md)\n\n## 数据下载\n\n我们将使用包含大约10K个单细胞的PBMC数据集。这个数据集是由10X基因组公司公开提供的，可以从 <https://www.dropbox.com/s/wn4mgwkkzqw2pox/SC3_v3_NextGem_DI_PBMC_10K_filtered_feature_bc_matrix.h5?dl=0> 下载。\n\n\n## 准备\n\n这个文章的内容灵感来自多个[Seurat 文档](https://satijalab.org/seurat/articles/get_started.html)。它假定你已经熟悉了最初的质控步骤。我们将从由cellranger生成的数据 x 细胞过滤矩阵开始，这是大多数分析的常见起点。\n\n我们将专注于单细胞RNA测序分析的两个具体关键任务：聚类和对已识别聚类的注释。\n\n## 安装包\n\n```r\ninstall.packages(\"Seurat\")\ninstall.packages(\"hdf5r\")\ninstall.packages(\"clustree\")\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"SingleR\")\nBiocManager::install(\"celldex\")\n```\n\n加载：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(Seurat)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAttaching SeuratObject\n```\n:::\n\n```{.r .cell-code}\nlibrary(patchwork)\nlibrary(clustree)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: ggraph\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: ggplot2\n```\n:::\n\n```{.r .cell-code}\nlibrary(SingleR)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: SummarizedExperiment\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MatrixGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: matrixStats\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'matrixStats'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:dplyr':\n\n    count\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MatrixGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stats4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BiocGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    combine, intersect, setdiff, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: S4Vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'S4Vectors'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    first, rename\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: IRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'IRanges'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    collapse, desc, slice\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomeInfoDb\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biobase\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'Biobase'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'SummarizedExperiment'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:SeuratObject':\n\n    Assays\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:Seurat':\n\n    Assays\n```\n:::\n\n```{.r .cell-code}\nlibrary(celldex)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'celldex'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:SingleR':\n\n    BlueprintEncodeData, DatabaseImmuneCellExpressionData,\n    HumanPrimaryCellAtlasData, ImmGenData, MonacoImmuneData,\n    MouseRNAseqData, NovershternHematopoieticData\n```\n:::\n:::\n\n\n## 读入数据集并创建一个 Seurat 对象\n\n首先，我们要读取10X测序数据并将其转换为 Seurat 对象。Seurat 对象作为一个容器，最初只包含 UMI 计数矩阵。但我们会向其添加更多的分析内容（例如PCA、聚类结果）。\n\n我们首先通过使用 `Read10X_h5` 函数读取计数矩阵，该函数从10X CellRanger hdf5文件中读取计数矩阵。层次数据格式（Hierarchical Data Format，HDF5或H5）提供了数据的更压缩的表示形式。Seurat 软件包包含多个读取函数，具体取决于文件格式。\n\n在读取数据时，我们会应用基本的质量控制，将低质量的细胞丢弃。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc.data <- Read10X_h5(filename=\"/Users/wsx/Library/CloudStorage/OneDrive-shanghaitech.edu.cn/Public/data/SC3_v3_NextGem_DI_PBMC_10K_filtered_feature_bc_matrix.h5\")\npbmc <- CreateSeuratObject(counts = pbmc.data, project = \"pbmc10k\", min.cells = 3, min.features = 200)\npbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\npbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 15)\n```\n:::\n\n\n接下来，我们计算线粒体RNA在总RNA含量中的百分比贡献。高线粒体含量可能表明正在经历凋亡的低质量细胞。我们根据线粒体含量和每个细胞特征数的分布再次进行质量控制。特征数过低可能表明空的液滴中存在环境RNA污染。特征数过高可能是由于多个细胞被困在同一个液滴中引起的。\n\n## 数据处理\n\n经过质量控制措施以选择继续分析的细胞后，接下来的步骤包括对数据进行归一化、识别高度可变特征以及进行尺度缩放。同时，还会进行主成分分析，因为许多后续分析步骤将在较低维度空间中进行计算。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- NormalizeData(pbmc)\npbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\nall.genes <- rownames(pbmc)\npbmc <- ScaleData(pbmc, features = all.genes)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCentering and scaling data matrix\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- RunPCA(pbmc, verbose = FALSE)\n```\n:::\n\n\n前面所有步骤的基本原理都与质量控制相关，在前面的教程中有更详细的介绍。\n\n## 选择主成分的数量\n\n首要的重要决策是在后续分析中保留多少个主成分（PCs）。保留的主成分越多，信号量也会增加，但同时也会增加噪音，并且计算需求也会增加。在做出这个选择之前，请检查与每个主成分相关的基因。存在与特定细胞类型相关的基因将表明该主成分具有信息量。而存在与所有不相关基因名称相关的情况则表明相反。在外周血单个核细胞（PBMC）的背景下，我们预期主要的细胞类型将包括T细胞、B细胞、NK细胞、单核细胞等等。\n\n检查前 10 个 PC，你会看到很多熟悉的基因名称。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(pbmc[[\"pca\"]], dims = 1:10, nfeatures = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPC_ 1 \nPositive:  LTB, IL32, TRAC, CD3D, TRBC2 \nNegative:  FCN1, FGL2, CST3, IFI30, TYMP \nPC_ 2 \nPositive:  MS4A1, CD79A, BANK1, IGHM, NIBAN3 \nNegative:  IL32, GZMM, CD3D, CD7, CD247 \nPC_ 3 \nPositive:  GZMB, CLIC3, NKG7, GNLY, KLRD1 \nNegative:  CCR7, LEF1, TRABD2A, TCF7, LTB \nPC_ 4 \nPositive:  CD79B, MS4A1, GNLY, CD79A, LINC00926 \nNegative:  LILRA4, CLEC4C, SERPINF1, TPM2, SCT \nPC_ 5 \nPositive:  CDKN1C, HES4, CTSL, TCF7L2, BATF3 \nNegative:  S100A12, ITGAM, VCAN, CES1, MGST1 \nPC_ 6 \nPositive:  CDKN1C, NRGN, PADI4, CKB, FCGR3A \nNegative:  CRIP1, GBP5, ISG15, NIBAN1, MAF \nPC_ 7 \nPositive:  CLU, ITGB1, NRGN, LIMS1, GP1BB \nNegative:  MALAT1, CCR7, TXK, LINC02446, KLRK1 \nPC_ 8 \nPositive:  CDKN1C, VIM, S100A4, CKB, ITGB1 \nNegative:  MAP3K7CL, SERPING1, GMPR, LGALS2, NEXN \nPC_ 9 \nPositive:  HERC5, IFIT1, RSAD2, IFIT3, MX1 \nNegative:  CLEC10A, FCER1A, ENHO, CD1C, CACNA2D3 \nPC_ 10 \nPositive:  TNFRSF13B, IGHG1, IGHA1, SSPN, IGFBP7 \nNegative:  TCL1A, CD8A, TRGC2, GZMK, CD8B \n```\n:::\n:::\n\n\n另一种可视化信息的方法是：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\",balanced=TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n这是另一种提供图示表示的方法。细胞和特征根据主成分分析得分进行排序。设置一个细胞数量有助于计算效率，因为它会忽略那些信息较少的极端细胞。强制使其平衡可在正相关和负相关之间获得相等的表示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nDimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nJackstraw 图用于估计每个主成分所捕获的结构的显著性。它会随机对数据的子集进行排列，以建立空值分布，并根据这个空值分布估计p值。\n\n⚠️ 这可能需要一些时间来执行。如果时间不够，请跳过这部分，然后只专注于接下来的拐点图。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- JackStraw(pbmc, num.replicate = 100)\npbmc <- ScoreJackStraw(pbmc, dims = 1:20)\nJackStrawPlot(pbmc, dims = 1:20)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 28000 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n拐点图是经典的计算机科学方法，用于检查通过逐个添加主成分来表示数据中累积变异性。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nElbowPlot(pbmc,ndims=50)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n根据这些图，我们选择使用20个主成分。但也可以为15到30之间的任何数量提出理由。\n\n我们使用UMAP来可视化数据集。我们提前计算UMAP，以便在需要时立即使用。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- RunUMAP(pbmc, dims = 1:20, verbose = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n```\n:::\n:::\n\n\n## 聚类\n\nSeurat默认的聚类算法采用基于图的聚类方法。它受到以前的发表文章的启发，这些文章在开发和改进这种方法方面做出了贡献。特别是，[《Phenograph》论文](http://www.ncbi.nlm.nih.gov/pubmed/26095251)强烈推荐给那些希望更好地理解这种方法的人。简要来说，聚类算法首先在PCA空间中计算每个细胞的K个最近邻。然后，根据共享邻居计算细胞之间的Jaccard相似性。使用Louvain算法对信息进行聚合，以便将细胞迭代地分组在一起。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- FindNeighbors(pbmc, dims = 1:20)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing nearest neighbor graph\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing SNN\n```\n:::\n:::\n\n\n第二个重要的决策是选择聚类的分辨率。较小的数值会生成混合的聚类，而较大的数值会产生过多的聚类，这些聚类可能不太具有意义。\n\n📝 对于你自己的研究，花一些时间来优化分辨率的选择是很有帮助的。尝试使用多个候选的分辨率选项来进行所有后续分析可能会有帮助。\n\n在这里，我们尝试三个不同的分辨率值，并使用clustree来研究其影响。在计算完聚类后，我们还保存了pbmc对象。\n\n\n::: {.cell}\n\n```{.r .cell-code}\npbmc <- FindClusters(object = pbmc,  resolution = c(0.5, 1, 1.5),  dims.use = 1:10,  save.SNN = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The following arguments are not used: dims.use, save.SNN\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSuggested parameter: dims instead of dims.use\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The following arguments are not used: dims.use, save.SNN\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSuggested parameter: dims instead of dims.use\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 9729\nNumber of edges: 356102\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9145\nNumber of communities: 16\nElapsed time: 1 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 9729\nNumber of edges: 356102\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8655\nNumber of communities: 20\nElapsed time: 1 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 9729\nNumber of edges: 356102\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8279\nNumber of communities: 22\nElapsed time: 1 seconds\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(pbmc, file = \"/Users/wsx/Library/CloudStorage/OneDrive-shanghaitech.edu.cn/Public/data/pbmc_tutorial.rds\")\nclustree(pbmc)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n这三行表示每个分辨率值下的细胞分配情况。每行中的节点大小表示该聚类中的细胞数量。行之间的箭头显示随着分辨率的增加，聚类的分配情况如何变化。稳定的聚类可能会更改名称，但是细胞在不同的分辨率下仍然会聚集在一起。一些聚类可能会分裂成两个（或更多）子聚类。这暗示着增加分辨率。但是，如果你看到聚类之间来回跳动的情况很多，那就表示稳定性较差。在你自己的数据中，最好进行过度聚类，然后检查基因，然后手动选择要合并的聚类。\n\n我们选择分辨率=0.5进行进一步检查：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIdents(pbmc) <- pbmc$RNA_snn_res.0.5\nDimPlot(pbmc, reduction = \"umap\", label=TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## 聚类富集标记\n\n\n接下来，对于每个聚类，我们想要检查在该聚类中相比其他细胞高度表达的特征（也称为标记或基因）。我们使用'roc'方法来估计每个标记的分类能力（0表示随机，1表示完美）。我们可以逐个聚类地进行这个分析，也可以同时对所有聚类进行分析。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster0.markers <- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = \"roc\", only.pos = TRUE)\n```\n:::\n\n\n⚠️ 对所有聚类执行此操作非常耗时。如果你想休息一下。在这样做之前启动它。计算时间可能长达30分钟。如果你在教程时间方面运行晚了，现在跳过这个和下面的热图。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster.all.markers0.5 <- FindAllMarkers(pbmc, logfc.threshold = 0.25, test.use = \"roc\", only.pos = TRUE, min.pct = 0.25)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 0\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 5\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 6\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 7\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 8\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 9\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 11\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 12\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 13\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 14\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nCalculating cluster 15\n```\n:::\n:::\n\n\n热图为共享高度表达标记的集群提供了很好的图形表示。注意到umap中这些集群之间的关系了吗?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster.all.markers0.5  %>%\n    group_by(cluster) %>%\n    top_n(n = 5, wt = avg_log2FC) -> top5\n\nDoHeatmap(pbmc, features = top5$gene) + NoLegend()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n接下来，我们选择一些标记，这些标记往往适用于PBMC数据集。其中许多来自`cluster.all.markers0.5`。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmarkers.to.plot <- c(\"CD3D\", \"HSPH1\", \"SELL\", \"CD14\", \"LYZ\", \"GIMAP5\", \"CACYBP\", \"GNLY\", \"NKG7\", \"CCL5\", \"CD8A\", \"MS4A1\", \"CD79A\", \"FCGR3A\", \"MS4A7\", \"S100A9\", \"HLA-DQA1\",\"GPR183\", \"PPBP\", \"GNG11\", \"TSPAN13\", \"IL3RA\", \"FCER1A\", \"CST3\", \"S100A12\")\n\nDotPlot(pbmc, features = markers.to.plot, cols = c(\"blue\", \"red\"), dot.scale = 8) +RotatedAxis()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"MS4A1\", \"CD79A\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"NKG7\", \"GNLY\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"FCGR3A\", \"MS4A7\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-3.png){width=672}\n:::\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"PPBP\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-4.png){width=672}\n:::\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"FCER1A\", \"CST3\"))   \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-5.png){width=672}\n:::\n\n```{.r .cell-code}\nVlnPlot(pbmc, features = c(\"CD8A\", \"CD8B\", \"CD3D\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-6.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFeaturePlot(pbmc, features = c(\"MS4A1\", \"GNLY\", \"CD3E\", \"CD14\", \"FCER1A\", \"FCGR3A\", \"LYZ\", \"PPBP\",  \"CD8A\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n## 基于参考的聚类注释\n\n基于参考数据的聚类注释不在Seurat软件包中进行。为此，我们将使用SingleR，并首先将Seurat数据的信息转换为SingleR的格式。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsce <- GetAssayData(object = pbmc, assay = \"RNA\", slot = \"data\")\n```\n:::\n\n\n我们将使用一篇[经典论文](https://pubmed.ncbi.nlm.nih.gov/30726743/)中的数据，该论文使用分类细胞对不同的免疫细胞类型进行了比较。基于参考数据的注释允许与高度精选的数据集进行直接比较。然而，缺点是推断的结果取决于参考数据集中定义的内容。\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrefMonaco <- MonacoImmuneData()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsnapshotDate(): 2022-10-31\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?celldex and browseVignettes('celldex') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nsee ?celldex and browseVignettes('celldex') for documentation\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nloading from cache\n```\n:::\n:::\n\n\n数据格式在两个层次上显示信息:主要细胞类型和更精细的分辨率信息：\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction_Monaco_main <- SingleR(test=sce, ref=refMonaco, clusters=Idents(pbmc), labels=refMonaco$label.main)\nprediction_Monaco_fine <- SingleR(test=sce, ref=refMonaco, clusters=Idents(pbmc), labels=refMonaco$label.fine)\n\npredicted_Monaco <- data.frame(cluster=sort(unique(Idents(pbmc))), Monaco_main= prediction_Monaco_main$labels, Monaco_fine= prediction_Monaco_fine$labels)\npredicted_Monaco\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   cluster     Monaco_main                  Monaco_fine\n1        0       Monocytes          Classical monocytes\n2        1    CD4+ T cells            Naive CD4 T cells\n3        2       Monocytes          Classical monocytes\n4        3    CD8+ T cells            Naive CD8 T cells\n5        4    CD4+ T cells               Th1/Th17 cells\n6        5         T cells           Non-Vd2 gd T cells\n7        6         B cells  Non-switched memory B cells\n8        7         B cells                Naive B cells\n9        8        NK cells         Natural killer cells\n10       9       Monocytes       Intermediate monocytes\n11      10         T cells                   MAIT cells\n12      11 Dendritic cells      Myeloid dendritic cells\n13      12 Dendritic cells Plasmacytoid dendritic cells\n14      13       Monocytes          Classical monocytes\n15      14     Progenitors             Progenitor cells\n16      15         B cells                 Plasmablasts\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}