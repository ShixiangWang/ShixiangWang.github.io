<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Reasoning</title>
<link>https://shixiangwang.github.io/index.html</link>
<atom:link href="https://shixiangwang.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>Reasoning is a blog dedicated to exploring the intersection of data science, bioinformatics, and personal insights.</description>
<generator>quarto-1.1.189</generator>
<lastBuildDate>Mon, 22 May 2023 16:00:00 GMT</lastBuildDate>
<item>
  <title>nextflow 运行 singularity no space left</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-05-23-nextflow-singularity-no-space-left/index.html</link>
  <description><![CDATA[ 




<p>运行 nextflow 时报错没有空间：</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><span class="ex" style="color: null;">Error</span> executing process <span class="op" style="color: #5E5E5E;">&gt;</span> <span class="st" style="color: #20794D;">'NFCORE_CIRCDNA:CIRCDNA:CNVKIT_BATCH (N87-TR)'</span></span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="ex" style="color: null;">Caused</span> by:</span>
<span id="cb1-4">  <span class="ex" style="color: null;">Process</span> <span class="kw" style="color: #003B4F;">`</span><span class="ex" style="color: null;">NFCORE_CIRCDNA:CIRCDNA:CNVKIT_BATCH</span> <span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">N87-TR</span><span class="kw" style="color: #003B4F;">)`</span> terminated with an error exit status <span class="er" style="color: #AD0000;">(</span><span class="ex" style="color: null;">255</span><span class="kw" style="color: #003B4F;">)</span></span>
<span id="cb1-5"></span>
<span id="cb1-6"><span class="ex" style="color: null;">Command</span> executed:</span>
<span id="cb1-7"></span>
<span id="cb1-8">  <span class="ex" style="color: null;">cnvkit.py</span> <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-9">      batch <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-10">      N87-TR.bam <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-11">       <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-12">      <span class="at" style="color: #657422;">--reference</span> GRCh38_cnvkit_filtered_ref.cnn <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-13">      <span class="at" style="color: #657422;">--processes</span> 4 <span class="dt" style="color: #AD0000;">\</span></span>
<span id="cb1-14">      <span class="at" style="color: #657422;">--method</span> wgs</span>
<span id="cb1-15"></span>
<span id="cb1-16">  <span class="fu" style="color: #4758AB;">cat</span> <span class="op" style="color: #5E5E5E;">&lt;&lt;-END_VERSIONS</span> <span class="op" style="color: #5E5E5E;">&gt;</span> versions.yml</span>
<span id="cb1-17"><span class="st" style="color: #20794D;">  "NFCORE_CIRCDNA:CIRCDNA:CNVKIT_BATCH":</span></span>
<span id="cb1-18"><span class="st" style="color: #20794D;">      cnvkit: </span><span class="va" style="color: #111111;">$(</span><span class="ex" style="color: null;">cnvkit.py</span> version <span class="kw" style="color: #003B4F;">|</span> <span class="fu" style="color: #4758AB;">sed</span> <span class="at" style="color: #657422;">-e</span> <span class="st" style="color: #20794D;">"s/cnvkit v//g"</span><span class="va" style="color: #111111;">)</span></span>
<span id="cb1-19"><span class="st" style="color: #20794D;">  END_VERSIONS</span></span>
<span id="cb1-20"></span>
<span id="cb1-21"><span class="st" style="color: #20794D;">Command exit status:</span></span>
<span id="cb1-22"><span class="st" style="color: #20794D;">  255</span></span>
<span id="cb1-23"></span>
<span id="cb1-24"><span class="st" style="color: #20794D;">Command output:</span></span>
<span id="cb1-25"><span class="st" style="color: #20794D;">  (empty)</span></span>
<span id="cb1-26"></span>
<span id="cb1-27"><span class="st" style="color: #20794D;">Command error:</span></span>
<span id="cb1-28"><span class="st" style="color: #20794D;">  INFO:    Converting SIF file to temporary sandbox...</span></span>
<span id="cb1-29"><span class="st" style="color: #20794D;">  FATAL:   while extracting /data3/wsx/nf-core-circdna-dev/workflow/../singularity-images/depot.galaxyproject.org-singularity-cnvkit-0.9.9--pyhdfd78af_0.img: root filesystem extraction failed: extract command failed: WARNING: passwd file doesn't exist in container, not updating</span></span>
<span id="cb1-30"><span class="st" style="color: #20794D;">  WARNING: group file doesn't exist in container, not updating</span></span>
<span id="cb1-31"><span class="st" style="color: #20794D;">  WARNING: Skipping mount /etc/hosts [binds]: /etc/hosts doesn't exist in container</span></span>
<span id="cb1-32"><span class="st" style="color: #20794D;">  WARNING: Skipping mount /etc/localtime [binds]: /etc/localtime doesn't exist in container</span></span>
<span id="cb1-33"><span class="st" style="color: #20794D;">  WARNING: Skipping mount proc [kernel]: /proc doesn't exist in container</span></span>
<span id="cb1-34"><span class="st" style="color: #20794D;">  WARNING: Skipping mount /data3/wsx/miniconda3/var/singularity/mnt/session/tmp [tmp]: /tmp doesn't exist in container</span></span>
<span id="cb1-35"><span class="st" style="color: #20794D;">  WARNING: Skipping mount /data3/wsx/miniconda3/var/singularity/mnt/session/var/tmp [tmp]: /var/tmp doesn't exist in container</span></span>
<span id="cb1-36"><span class="st" style="color: #20794D;">  WARNING: Skipping mount /data3/wsx/miniconda3/var/singularity/mnt/session/etc/resolv.conf [files]: /etc/resolv.conf doesn't exist in container</span></span>
<span id="cb1-37"></span>
<span id="cb1-38"><span class="st" style="color: #20794D;">  Write on output file failed because No space left on device</span></span>
<span id="cb1-39"></span>
<span id="cb1-40"><span class="st" style="color: #20794D;">  FATAL ERROR:writer: failed to write file /image/root/.singularity.d/startscript</span></span>
<span id="cb1-41"><span class="st" style="color: #20794D;">  Parallel unsquashfs: Using 48 processors</span></span>
<span id="cb1-42"><span class="st" style="color: #20794D;">  29783 inodes (35465 blocks) to write</span></span>
<span id="cb1-43"></span>
<span id="cb1-44"><span class="st" style="color: #20794D;">  : exit status 1</span></span>
<span id="cb1-45"></span>
<span id="cb1-46"><span class="st" style="color: #20794D;">Work dir:</span></span>
<span id="cb1-47"><span class="st" style="color: #20794D;">  /data3/wsx/nxf_wgs/work/e9/902f1684d95d41a61ae28ef3e529b3</span></span>
<span id="cb1-48"></span>
<span id="cb1-49"><span class="st" style="color: #20794D;">Tip: when you have fixed the problem you can continue the execution adding the option </span><span class="kw" style="color: #003B4F;">`</span><span class="ex" style="color: null;">-resume</span><span class="kw" style="color: #003B4F;">`</span> to the run command line</span></code></pre></div>
<p>我查了下 <code>/tmp</code> 缺失很少或没有了，尝试删除我自己产生的临时目录再次运行还是报错。原因是 singularity 镜像在 <code>/tmp</code> 目录下解压空间不够导致的。</p>
<p>实际上我在 <code>~/.bashrc</code> 下是设置过临时目录和singularity的缓存的：</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode sh code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">TMPDIR</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/TEMPDIR</span>
<span id="cb2-2"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">TEMP</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/TEMPDIR</span>
<span id="cb2-3"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">TMP</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/TEMPDIR</span>
<span id="cb2-4"></span>
<span id="cb2-5"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">NXF_SINGULARITY_CACHEDIR</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/NXF_singularity</span>
<span id="cb2-6"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">SINGULARITY_TMPDIR</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/singularity-env</span>
<span id="cb2-7"><span class="bu" style="color: null;">export</span> <span class="va" style="color: #111111;">SINGULARITY_CACHEDIR</span><span class="op" style="color: #5E5E5E;">=</span><span class="va" style="color: #111111;">$HOME</span>/singularity-env</span></code></pre></div>
<p>这就相当纳闷了。在 Github 发现一个<a href="https://github.com/nextflow-io/nextflow/issues/2786">帖子</a>，讨论说这个问题是 nextflow 没有正常地读取和设置 singularity 的临时目录磁盘挂载。</p>
<p>想一想，确实是这个问题。为了确定，我在报错的 work 目录下查看和调试了 <code>.command.run</code> 文件，当设置挂载后确实是可以正常工作的。</p>
<p>于是按照下面进行了 <code>nextflow.config</code> 的配置：</p>
<pre><code>singularity {
enabled = true
autoMounts = true
runOptions = '-B $SINGULARITY_TMPDIR:/tmp -B $SINGULARITY_TMPDIR:/scratch'
//Used to allow Singularity to access bashrc variables
envWhitelist = ['SINGULARITY_TMPDIR']
}</code></pre>
<p>还是不行，后面对比时猛然发现在 <code>nextflow.config</code> 中 <code>autoMounts</code> 的写法是 <code>singularity.autoMounts = true</code>。 所以我添加了前缀：</p>
<pre><code>singularity.autoMounts = true
singularity.runOptions = '-B $SINGULARITY_TMPDIR:/tmp'
singularity.envWhitelist = ['SINGULARITY_TMPDIR']</code></pre>
<p>这样就没有问题了。</p>



 ]]></description>
  <category>debug</category>
  <guid>https://shixiangwang.github.io/posts/2023-05-23-nextflow-singularity-no-space-left/index.html</guid>
  <pubDate>Mon, 22 May 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>Single-cell sequencing protocols</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-05-12-single-cell-sequencing-protocols/index.html</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>From <a href="https://www.sc-best-practices.org/introduction/scrna_seq.html" class="uri">https://www.sc-best-practices.org/introduction/scrna_seq.html</a></p>
</blockquote>
<p>Types:</p>
<ul>
<li>microfluidic device-based strategies where cells are encapsulated into hydrogel droplets</li>
<li>well plate based protocols where cells are physically separated into wells</li>
<li>the commercial Fluidigm C1 microfluidic chip based solution which loads and separates cells into small reaction chambers</li>
</ul>
<section id="基于微流控装置" class="level2">
<h2 class="anchored" data-anchor-id="基于微流控装置">基于微流控装置</h2>
<p>基于微流控芯片的单细胞策略可以将细胞固定在水凝胶液滴内部，实现将其分隔到单细胞反应室中。最广泛使用的协议有inDrop [Klein等人，2015]、Drop-seq [Macosko等人，2015]和商业可用的10x Genomics Chromium [Zheng等人，2017]，能够每秒生成数千个这样的液滴。这种大规模并行的过程以相对较低的成本生成非常多的液滴。虽然这三个协议在细节上有所不同，但始终设计了包含携带PCR处理程序、细胞条形码和4-8个碱基对长的唯一分子标识符（UMI）和poly-T尾巴的专门微珠来封装细胞的纳升级液滴，以便同时捕获微珠和细胞。封装过程是使用具有on-bead引物的专门微珠进行的，这些引物包含一个PCR处理程序、一个细胞条形码和一个4-8 bp长的唯一分子标识符（UMI）和一个poly-T尾巴。在裂解后，细胞的mRNA立即被释放，并被附加在微珠上的带条形码的寡核苷酸捕获。接下来，收集液滴并将其打破以释放连接到微粒（STAMPs）上的单个细胞转录组。然后进行PCR和反转录以捕获和扩增转录物。最后进行标签切割，其中转录本被随机切割并附加测序适配器。该过程产生了用于测序的测序文库，如上所述。在基于微流控芯片的协议中，细胞的约10%的转录本会被检测到[Islam等人，2014]。值得注意的是，这种低测序量已足以稳健地识别细胞类型。</p>
<p>所有三种基于微流控芯片的方法都会产生特定的偏差。所使用的微珠材料在协议之间存在差异。Drop-seq使用脆性树脂制成的微珠，因此微珠被以泊松分布封装，而InDrop和10X Genomics微珠是可变形的，导致微珠的占用率超过80%[Zhang等人，2019]。此外，Drop-Seq中使用表面固定引物可能会影响捕获效率。InDrop使用光解引物释放，而10X genomics则溶解微珠。这种差异也影响了反转录过程的位置。在Drop-seq中，反转录发生在微珠从液滴中释放后，而在InDrop和10X genomics协议中，反转录发生在液滴内部[Zhang等人，2019]。</p>
<p>2019年张等人的比较发现，就微珠质量而言，10X Genomics比inDrop和Drop-seq表现更好，因为前两个系统中的细胞条形码存在明显的不匹配。此外，从有效条形码中产生的读数比例对于10X Genomics是75%，而对于InDrop和Drop-seq仅分别为25%和30%。</p>
<p>在敏感性方面，10X Genomics也表现出类似的优势。他们的比较显示，平均而言，10X Genomics捕获了来自3000个基因的约17000份转录本，而Drop-seq只有来自2500个基因的约8000份转录本，InDrop则只有来自1250个基因的约2700份转录本。技术噪音最小的是10X Genomics，其次是Drop-seq和InDrop[Zhang等人，2019]。</p>
<p>实际生成的数据展示了大量的协议偏差。10X Genomics更倾向于捕获和扩增长度较短的基因和GC含量较高的基因，而相比之下，Drop-seq更倾向于GC含量较低的基因。尽管10X Genomics在各个方面的表现都超过了其他协议，但它每个细胞的成本也是其他协议的两倍左右。此外，除了微珠以外，Drop-seq是开源的，协议可以更容易地进行适应性调整。InDrop完全是开放源代码的，甚至可以在实验室中制造和修改微珠。因此，InDrop是三种协议中最灵活的一种。</p>
<ul>
<li>优点：</li>
</ul>
<p>可以以成本效益的方式对大量细胞进行测序，以识别组织的总体组成并表征罕见的细胞类型。</p>
<p>可以加入唯一分子标识符（UMIs）。</p>
<ul>
<li>限制：</li>
</ul>
<p>与其他方法相比，转录本检测率较低。</p>
<p>只能捕获3’端而非全长转录本，因为细胞条形码和PCR处理程序仅添加到转录本的末端。</p>
</section>
<section id="基于板" class="level2">
<h2 class="anchored" data-anchor-id="基于板">基于板</h2>
<p>基于板的协议通常将细胞物理地分离到微孔板中。第一步涉及通过荧光激活细胞分选（FACS）等方法对细胞进行分选，其中根据特定的细胞表面标记对细胞进行排序；或通过微型移液进行。然后将所选细胞放入含有细胞裂解缓冲液的单个孔中，随后进行反转录。这样可以在单次实验中分析数百个细胞，并每个细胞捕获5000至10000个基因。基于板的测序协议包括但不限于SMART-seq2、MARS-seq、QUARTZ-seq和SRCB-seq。总的来说，这些协议在其多重复合能力方面存在差异。例如，MARS-seq允许三个条形码级别，即分子、细胞和板级标签，以实现强大的多重复合功能。相反，SMART-seq2不允许早期多重复合，从而限制了细胞数目。Mereu等人在2020年进行的系统比较显示，与SMART-seq2、MARS-seq或SRCB-seq相比，QUARTZ-seq2能够捕获更多的基因[Mereu等人，2020]，这意味着QUARTZ-seq2能够很好地捕获细胞类型特异性标记基因，从而实现可靠的细胞类型注释。</p>
<ul>
<li>优点：</li>
</ul>
<p>每个细胞可以恢复许多基因，从而进行深入的表征。</p>
<p>可能在库制备之前收集信息，例如通过FACS排序将细胞大小和任何使用的标记的强度与孔座标关联起来。</p>
<p>允许完整的转录本恢复。</p>
<ul>
<li>限制：</li>
</ul>
<p>基于板的实验规模受到其单个处理单元较低的吞吐量的限制。</p>
<p>断裂步骤会消除链特异性信息[Hrdlickova等人，2017]。</p>
<p>根据协议不同，基于板的协议可能是人力密集型的，需要许多必需的移液步骤，导致潜在的技术噪声和批次效应。</p>
</section>
<section id="fluidigm-c1" class="level2">
<h2 class="anchored" data-anchor-id="fluidigm-c1">Fluidigm C1</h2>
<p>商业的Fluidigm C1系统是一种微流控芯片，可以自动将细胞加载和分离到小反应室中。 CEL-seq2和SMART-seq（版本1）协议在其工作流程中使用Fluidigm C1芯片，允许RNA提取和文库制备步骤同时进行，从而减少所需的手动劳动。但是，Fluidigm C1需要相对均匀的细胞混合物，因为细胞基于其大小会到达微流控芯片上的不同位置，可能会引入潜在的空间偏差。由于扩增步骤是在单个孔中进行的，因此可以实现全长测序，有效地减少了许多其他单细胞RNA测序协议的3’偏差。该协议通常也更昂贵，因此主要用于特定细胞群的广泛检查。</p>
<ul>
<li>优点：</li>
</ul>
<p>允许全长转录本覆盖。</p>
<p>可以恢复剪接变异和T/B细胞受体多样性。</p>
<ul>
<li>限制：</li>
</ul>
<p>仅允许对最多800个细胞进行测序[Fluidigm，2022]。</p>
<p>每个细胞的成本比其他协议更高。</p>
</section>
<section id="纳米孔单细胞转录组测序" class="level2">
<h2 class="anchored" data-anchor-id="纳米孔单细胞转录组测序">纳米孔单细胞转录组测序</h2>
<p>长读单细胞测序方法很少使用UMI [Singh等人，2019]或未执行UMI校正[Gupta等人，2018]，因此将新的UMI读取分配给新的UMI。由于长读测序器的较高测序误差率，这会导致严重问题[Lebrigand等人，2020]。Lebigrand等人引入了ScNaUmi-seq（带有UMI的单细胞Nanopore测序），它将Nanopore测序与细胞条形码和UMI分配相结合。通过比较在Nanopore读取中发现的细胞条形码序列和从同一区域或基因恢复的 Illumina读取中发现的序列，利用Illumina数据指导条形码分配[Lebrigand等人，2020]。然而，这实际上需要两个单细胞库。scCOLOR-seq使用在整个条形码长度上互补的核苷酸对计算识别无误差的条形码。然后使用这些条形码作为指南来纠正其余的错误条形码[Philpott等人，2021]。修改过的UMI-tools定向网络方法可以纠正UMI序列重复。</p>
<ul>
<li>优点：</li>
</ul>
<p>恢复剪接和序列异质性信息</p>
<ul>
<li>缺点：</li>
</ul>
<p>Nanopore试剂昂贵。</p>
<p>细胞条形码恢复错误率高。</p>
<p>根据协议不同，条形码分配使用Illumina数据进行指导，需要两个测序试验。 只有约10%的提取细胞被捕获，使该协议不适用于罕见细胞类型或低输入。</p>
<p>使用的阵列仅捕获特定的细胞大小，可能会引入偏差。</p>
</section>
<section id="总结" class="level2">
<h2 class="anchored" data-anchor-id="总结">总结</h2>
<p>总的来说，我们强烈建议湿实验室和干实验室的科学家根据研究目的选择测序协议。是希望对特定细胞类型人群进行深入表征吗？在这种情况下，其中一种基于板的方法可能更适合。相反，基于液滴的测定会更好地捕获异质性混合物，从而允许更广泛的细胞表征。此外，如果预算是一个限制因素，则应选择更具成本效益和稳健性的协议。在分析数据时，请注意测序试验特异性偏差。为了全面比较所有单细胞测序协议，我们建议参考Mereu等人的“<a href="https://www.nature.com/articles/s41587-020-0469-4">Benchmarking single-cell RNA-sequencing protocols for cell atlas projects</a>”论文[Mereu等人，2020]。</p>


</section>

 ]]></description>
  <category>bioinformatics</category>
  <category>note</category>
  <guid>https://shixiangwang.github.io/posts/2023-05-12-single-cell-sequencing-protocols/index.html</guid>
  <pubDate>Thu, 11 May 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>Start a new research direction</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-05-12-start-a-new-research-direction/index.html</link>
  <description><![CDATA[ 




<blockquote class="blockquote">
<p>Copied from a slide (Liulab?).</p>
</blockquote>
<ul>
<li>Is the new direction is important?
<ul>
<li>I can explain its importance to laymen</li>
<li>There are basic science, translational and industry interests</li>
<li>I am willing to devote the next 5-10 years working on it</li>
</ul></li>
<li>Do we have any advantage working on this?</li>
<li>What can we actually do (expertise)?</li>
</ul>



 ]]></description>
  <category>academic</category>
  <guid>https://shixiangwang.github.io/posts/2023-05-12-start-a-new-research-direction/index.html</guid>
  <pubDate>Thu, 11 May 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>晒晒娃和Y叔R书的合照</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-04-08-yiyi-with-book-by-y/index.html</link>
  <description><![CDATA[ 




<p>买了一本Y叔最新出的新书，出版社的张编辑又送了一本，这里晒一下崽崽和图书的照片。</p>
<p><img src="https://shixiangwang.github.io/posts/2023-04-08-yiyi-with-book-by-y/IMG_6364.JPG" class="img-fluid"></p>
<blockquote class="blockquote">
<p>摄影自我媳妇</p>
</blockquote>



 ]]></description>
  <category>personal</category>
  <category>R</category>
  <guid>https://shixiangwang.github.io/posts/2023-04-08-yiyi-with-book-by-y/index.html</guid>
  <pubDate>Fri, 07 Apr 2023 16:00:00 GMT</pubDate>
  <media:content url="https://shixiangwang.github.io/posts/2023-04-08-yiyi-with-book-by-y/IMG_6364.JPG" medium="image"/>
</item>
<item>
  <title>随想</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-05-02-random/index.html</link>
  <description><![CDATA[ 




<p>越长大，突然明白这个世界都是在玩一场资源分配的游戏。</p>
<p>卷不是目的，只是无能为力。</p>
<p>超脱者永远是少数。</p>
<p>所谓，求仙不得仙，只能老实做人。</p>



 ]]></description>
  <category>personal</category>
  <guid>https://shixiangwang.github.io/posts/2023-05-02-random/index.html</guid>
  <pubDate>Fri, 07 Apr 2023 16:00:00 GMT</pubDate>
</item>
<item>
  <title>ChatGPT 帮助我理解 Rust 的所有权</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/2023-03-29-chatgpt-help-me-understand-rust-ownership/index.html</link>
  <description><![CDATA[ 




<p>这篇文章以我和 ChatGPT 的问答进行。</p>
<section id="怎么理解rust的所有权" class="level2">
<h2 class="anchored" data-anchor-id="怎么理解rust的所有权">怎么理解rust的所有权？</h2>
<p>Rust的所有权是其独特的内存管理系统，用于动态内存分配和释放。它基于以下原则：</p>
<ol type="1">
<li><p>每个值在任何时刻只能有一个所有者。</p></li>
<li><p>所有权只能转移，不能共享。</p></li>
<li><p>默认情况下，所有权的转移是按值而不是按引用进行的。</p></li>
</ol>
<p>这种所有权系统有助于避免内存泄漏、空引用和数据竞争等常见的错误。在Rust中，通过为每个值分配一个所有者来跟踪内存中的数据是如何使用的，每一个所有者离开作用域时，它拥有的值都会被销毁。因此，Rust所有权系统能够自动管理内存，而且无需额外的垃圾回收机制。这一特性让Rust成为一个高效、安全和可靠的编程语言。需要注意的是，所有权机制对于Rust的初学者来说是一个相对复杂的概念，需要一定的理解和实践才能更好地应用它并编写出高质量的Rust代码。</p>
</section>
<section id="怎么理解-所有权的主要目的就是为了管理堆数据" class="level2">
<h2 class="anchored" data-anchor-id="怎么理解-所有权的主要目的就是为了管理堆数据">怎么理解 所有权的主要目的就是为了管理堆数据？</h2>
<p>Rust中的所有权确实是用于管理堆数据的，因为堆数据是在运行时动态分配的，并且在内存中存在一定的问题，如内存泄漏、数据竞争等。因此需要一种机制来管理堆数据并解决这些问题。所有权机制可以确保在动态分配内存的情况下，内存得到正确的释放，每个heap上的数据有且仅有一个所有者对其进行管理，从而避免了数据竞争和其他常见的错误。</p>
<p>此外，Rust还使用采取堆管理的方式为其他类型的数据分配内存。例如，当一个Vector或String类型增长时，它们必须重新分配和复制所有的数据，同时保证新的数据具有唯一的所有者。这使得Rust的动态内存分配和释放机制非常高效、可靠和安全，在许多应用程序场景中可以提供非常好的性能。</p>
</section>
<section id="为什么所有权不是管理栈数据的呢" class="level2">
<h2 class="anchored" data-anchor-id="为什么所有权不是管理栈数据的呢">为什么所有权不是管理栈数据的呢？</h2>
<p>所有权的设计之所以没有涉及栈，是因为栈上的数据是随着当前作用域结束而自动释放的。栈上的数据的分配和释放是编译时完成的，编译器可以自己进行管理，从而不需要特别的内存管理机制。当在栈上分配数据时，其生命周期的结束是在编译器处理的代码块退出前的最后一个语句执行后就会自动发生。此时编译器会自动释放它们的空间，没有必要使用所有权。因此，所有权机制主要应用于需要在运行时动态分配内存的场景，例如堆上存储的大型数据结构、字符串、闭包等。相比于栈上的数据，堆上的数据需要更加灵活和高级的处理方式，所以所有权体系的设计针对的是动态内存的管理，而不是栈上的处理。</p>
</section>
<section id="所有权造成的操作障碍" class="level2">
<h2 class="anchored" data-anchor-id="所有权造成的操作障碍">所有权造成的操作障碍</h2>
<p>由于所有权的问题，Rust 变得安全有效，但对于开发者也造成了一些理解和操作问题。 例如，同一个<strong>堆数据</strong>（栈数据不会受到影响，因为它们在编译时已经被决定了，堆数据在运行时是可变的，所以才会有内存问题）不能指向两个不同的变量，当新的变量出现时，所有权被转移，之前的变量就无效无法使用了。</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb1-1"><span class="kw" style="color: #003B4F;">fn</span> main() <span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb1-2">    <span class="kw" style="color: #003B4F;">let</span> s1 <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"hello"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-3">    <span class="kw" style="color: #003B4F;">let</span> s2 <span class="op" style="color: #5E5E5E;">=</span> s1<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-4"></span>
<span id="cb1-5">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"{}, world!"</span><span class="op" style="color: #5E5E5E;">,</span> s1)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb1-6"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p><img src="https://shixiangwang.github.io/posts/2023-03-29-chatgpt-help-me-understand-rust-ownership/https:/kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg" class="img-fluid"></p>
<p>为了生成两个拷贝，需要用到克隆。</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode rust code-with-copy"><code class="sourceCode rust"><span id="cb2-1"><span class="kw" style="color: #003B4F;">fn</span> main() <span class="op" style="color: #5E5E5E;">{</span></span>
<span id="cb2-2">    <span class="kw" style="color: #003B4F;">let</span> s1 <span class="op" style="color: #5E5E5E;">=</span> <span class="dt" style="color: #AD0000;">String</span><span class="pp" style="color: #AD0000;">::</span>from(<span class="st" style="color: #20794D;">"hello"</span>)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-3">    <span class="kw" style="color: #003B4F;">let</span> s2 <span class="op" style="color: #5E5E5E;">=</span> s1<span class="op" style="color: #5E5E5E;">.</span>clone()<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-4"></span>
<span id="cb2-5">    <span class="pp" style="color: #AD0000;">println!</span>(<span class="st" style="color: #20794D;">"s1 = {}, s2 = {}"</span><span class="op" style="color: #5E5E5E;">,</span> s1<span class="op" style="color: #5E5E5E;">,</span> s2)<span class="op" style="color: #5E5E5E;">;</span></span>
<span id="cb2-6"><span class="op" style="color: #5E5E5E;">}</span></span></code></pre></div>
<p>这个 Rust 的 trait 设计也有关系（我理解就是实际的实现）</p>
<blockquote class="blockquote">
<p>Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。</p>
<p>Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。</p>
<p>那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：</p>
<p>所有整数类型，比如 u32。 布尔类型，bool，它的值是 true 和 false。 所有浮点数类型，比如 f64。 字符类型，char。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</p>
</blockquote>
<p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html" class="uri">https://kaisery.github.io/trpl-zh-cn/ch04-01-what-is-ownership.html</a></li>
</ul>


</section>

 ]]></description>
  <category>Rust</category>
  <category>AI</category>
  <guid>https://shixiangwang.github.io/posts/2023-03-29-chatgpt-help-me-understand-rust-ownership/index.html</guid>
  <pubDate>Tue, 28 Mar 2023 16:00:00 GMT</pubDate>
  <media:content url="https://kaisery.github.io/trpl-zh-cn/img/trpl04-04.svg" medium="image" type="image/svg+xml"/>
</item>
<item>
  <title>Welcome To My Blog</title>
  <dc:creator>Shixiang Wang</dc:creator>
  <link>https://shixiangwang.github.io/posts/welcome/index.html</link>
  <description><![CDATA[ 




<p>This is the first post in a Quarto blog. Welcome!</p>
<p><img src="https://shixiangwang.github.io/posts/welcome/thumbnail.jpg" class="img-fluid"></p>



 ]]></description>
  <category>news</category>
  <guid>https://shixiangwang.github.io/posts/welcome/index.html</guid>
  <pubDate>Mon, 27 Mar 2023 16:00:00 GMT</pubDate>
  <media:content url="https://shixiangwang.github.io/posts/welcome/thumbnail.jpg" medium="image" type="image/jpeg"/>
</item>
</channel>
</rss>
