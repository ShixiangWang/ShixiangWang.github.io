<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Garrick Aden-Buie's Blog</title>
    <link>/blog/</link>
    <description>Recent posts from Garrick Aden-Buie</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Aug 2021 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>forestmodel给多水平变量添加整体p值</title>
      <link>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</guid>
      <description>前段时间收到来信：
1Hi Shixiang 2 3I am writing to you about the forestmodel package in R. 4 5Thank you so much for the wonderful package that you created. 6 7I was wondering if there is a way to display the wald test p-value which is important for variables that have more than two levels. I tried to work around the code but did not find a way out. 8 9Best 10Aniket 我不是作者，搞错了人，问我干啥呢～自个提问嘛</description>
    </item>
    
    <item>
      <title>PR曲线与AUC</title>
      <link>/blog/pr-curve-and-auc-value/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/pr-curve-and-auc-value/</guid>
      <description>这里直接使用ROCR包提供的数据作为示例：
library(ROCR) data(ROCR.simple) pred &amp;amp;lt;- prediction(ROCR.simple$predictions, ROCR.simple$labels) perf &amp;amp;lt;- performance(pred,&amp;amp;quot;tpr&amp;amp;quot;,&amp;amp;quot;fpr&amp;amp;quot;) plot(perf) ## precision/recall curve (x-axis: recall, y-axis: precision) perf1 &amp;amp;lt;- performance(pred, &amp;amp;quot;prec&amp;amp;quot;, &amp;amp;quot;rec&amp;amp;quot;) plot(perf1, xlim = c(0, 1), ylim = c(0, 1)) 使用 PRROC 包获取PR AUC值并且绘图：
pr &amp;amp;lt;- PRROC::pr.curve(ROCR.simple$predictions, weights.class0 = ROCR.simple$labels, curve = TRUE) pr ## ## Precision-recall curve ## ## Area under curve (Integral): ## 0.7815038 ## ## Area under curve (Davis &amp;amp;amp; Goadrich): ## 0.7814246 ## ## Curve for scores from 0.</description>
    </item>
    
    <item>
      <title>《R语言数据科学导论》笔记</title>
      <link>/blog/note-for-r-data-science-intro/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/note-for-r-data-science-intro/</guid>
      <description>原始资料来源：https://github.com/leovan/data-science-introduction-with-r
特征工程 特征工程是将原始数据转换成特征的过程。更通俗地说，特征工程就是人工设计模型的输入变量 x的过程。
主要分为：
 数据预处理 特征提取和选择 特征变换和编码 特征监控  数据预处理 对赃数据进行清洗，包括括缺失，噪声，不一致等等一系列问题数据。
剔除处理：
 样本去重。同一个ID出现多次重复记录。 特征去重。例如月收入和年收入，它们都是用于表征收入特征，关系只差常数倍。 常量特征剔除。即常量或方差近似为0的特征。caret包中的nearZeroVar()可以帮助我们识别该类特征。  缺失值处理：
 探索缺失值：mice包的md.pattern()，VIM包的aggr()/marginplot()。 处理：  删除法，可以直接使用na.omit()。 插补法，如果该特征对最终的预测结果影响较小，则我们可以直接删除该特征；相反如果该特征对预测结果影响较大，直接删除会对模型造成较大的影 响，此时我们需要利用其它的方法对该特征的缺失值进行填补。其中最简单的方式是利用均值，中位数或众数等统计量对其进行简单插补。这种插补方法是建立在完全随机缺失的前提假设下，同时会造成变量方差变小。    异常值是指样本中存在的同样本整体差异较大的数据。
分为2类：
采样是一种常见的预处理技术。
 随机采样。每个样本单位被抽中的概率相等，样本的每个单位完全独立，彼此间无一定的关联性和排斥性。 分层采样。将抽样单位按某种特征或某种规则划分为不同的层，然后从不同的层中独立、随机地抽取样本。从而保证样本的结构与总体的结构比较相近，从而提高估计的精度。可以利用sampling::strata()。 欠采样和过采样。我们经常会碰到不同分类的样本比例相差较大的问题，这种问题会对我们构建模型造成很大的影响，因此从数据角度出发，我们可以利用欠采样或过采样处理这种现象。可以利用ROSE::ovun.sample()。  特征变换和编码 无量纲化 通过归一化，我们可以消除不同量纲下的数据对最终结果的影响。
1normalize &amp;amp;lt;- function(x) { 2 # 计算极值 3 x_min &amp;amp;lt;- min(x) 4 x_max &amp;amp;lt;- max(x) 5 # 归一化 6 x_n &amp;amp;lt;- (x - x_min) / 7 (x_max - x_min) 8 # 将极值作为结果的属性 9 attr(x_n, 10 &amp;amp;#39;min&amp;amp;#39;) &amp;amp;lt;- x_min 11 attr(x_n, 12 &amp;amp;#39;max&amp;amp;#39;) &amp;amp;lt;- x_max 13 # 返回归一化后结果 14 x_n 15} 标准化。</description>
    </item>
    
    <item>
      <title>解决由于网络问题导致的stringi安装失败问题</title>
      <link>/blog/install-stringi-when-bad-acess-to-gh/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/install-stringi-when-bad-acess-to-gh/</guid>
      <description>这是一个我每次重装R，或者在新的系统上使用R进行包安装，都会遇到的问题。
stringi是tidyverse的一个核心包，基本上必装。但由于gayhub经常访问有问题，这个包安装时所需要的依赖文件会下载不了。 解决的办法是手动下载，然后进行安装：
1wget https://github.com/gagolews/stringi/archive/master.zip -O stringi.zip 2# 如果上面github的链接无法下载，尝试： 3# wget https://download.fastgit.org/gagolews/stringi/archive/master.zip -O stringi.zip 4unzip stringi.zip 5sed -i &amp;amp;#39;/\/icu..\/data/d&amp;amp;#39; stringi-master/.Rbuildignore 6R CMD build stringi-master 7R CMD INSTALL stringi*.tar.gz 参考：https://stackoverflow.com/questions/31942322/how-to-install-stringi-from-local-file-absolutely-no-internet-access#</description>
    </item>
    
    <item>
      <title>CentOS/Redhat R包使用最新的gcc编译</title>
      <link>/blog/use-new-gcc-on-centos-for-r/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-new-gcc-on-centos-for-r/</guid>
      <description>R包在Linux下编译不通过，原因是gcc版本太低怎么办？
一些有C&#43;&#43;代码的R包可能会用到一些新的C&#43;&#43;特性，需要C&#43;&#43;11或者C&#43;&#43;14。这个问题通常在CentOS/红帽系统上出现，因为系统稳定的要求，这个系列的系统它的C&#43;&#43;版本很低。 但请读者前往注意了别自己编译新版本的gcc，然后替换掉系统的。这种操作我试过几次，系统基本上就崩掉了。
正确的解决方式是安装独立的gcc，通过环境变量引用和使用它。
在Root用户下操作：
1yum install centos-release-scl 2yum install devtoolset-9 然后在你使用R的用户下操作：
1# If you use your non-root account to install packages,  2# change /root to /home/your_id in the following command 3mkdir -p /root/.R 4vi /root/.R/Makevars 将下面的内容写入打开的文件，然后保存：
1CXX11=/opt/rh/devtoolset-9/root/usr/bin/g&#43;&#43; -std=c&#43;&#43;11 -fPIC 2CXX14=/opt/rh/devtoolset-9/root/usr/bin/g&#43;&#43; -std=c&#43;&#43;14 -fPIC </description>
    </item>
    
    <item>
      <title>使用modules包来组织R的函数集合</title>
      <link>/blog/use-modules-to-organize-r-functions/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-modules-to-organize-r-functions/</guid>
      <description>接触过Python的朋友肯定对模块很熟悉，R的代码组织方式以包为主。但基于文件的模块形式也是可以实现的，modules 包提供了这种支持。
安装和使用 直接从CRAN下载即可：
1install.packages(&amp;amp;#34;modules&amp;amp;#34;) 使用了解2个函数的使用就可以了。
一是import()，用于替换library()加载包。
1&amp;amp;gt; library(modules) 2&amp;amp;gt; gp = import(&amp;amp;#39;ggplot2&amp;amp;#39;) 3Masking (modules:ggplot2): 4 `Position` from: base 5&amp;amp;gt; args(gp$ggplot) 6function (data = NULL, mapping = aes(), ..., environment = parent.frame()) 7NULL 8&amp;amp;gt; args(ggplot) 9function (data = NULL, mapping = aes(), ..., environment = parent.frame()) 10NULL 这样我们可以直接使用这个函数，也可以通过gp这个对象去访问可用的函数。
如果不想要在全局直接访问包内的函数，在导入时设定attach=FALSE。
1&amp;amp;gt; dp &amp;amp;lt;- import(dplyr, attach = FALSE) 2Masking (modules:dplyr): 3 `intersect` from: base 4 `setdiff` from: base 5 `setequal` from: base 6 `union` from: base 7&amp;amp;gt; select 8错误: 找不到对象&amp;amp;#39;select&amp;amp;#39; 9&amp;amp;gt; dp$select 10function (.</description>
    </item>
    
    <item>
      <title>Shell：工具工作技巧备忘</title>
      <link>/blog/unix-working-tricks/</link>
      <pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-working-tricks/</guid>
      <description>远程传输和备份文件（夹） 使用scp无法续传，使用rsync更好。
1rsync -avLr --progress huaxi:/remote_dir/ ./local_dir 从bed文件指定的区域提取bam结果 1samtools view -@ 4 -bhL ../regions_to_check_in_bam.bed /public/home/zhaoxxx.bam &amp;amp;gt; xxx.bam </description>
    </item>
    
    <item>
      <title>RNAseq原理与分析课程笔记</title>
      <link>/blog/rnaseq-cource-notes/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rnaseq-cource-notes/</guid>
      <description>很久之前在腾讯课堂购买了孟浩巍的RNAseq课程，讲解的挺细致完备的。这里主要是很少做这样的分析，所以一方面扫盲，一方面记录下其中重要的点（自己不知道的）或者值得拓展了解的知识点。
参考基因组与基因分布 拼装失败的地方大都是rRNA位置区域，与后面的内容对应。
rRNA 这里有几个点：
 一个DNA分子是比一个氨基酸大的 rRNA是集中分布的 rRNA在全部RNA中的占比很高，达80%左右。所以mRNA测序要么富集poly-A，要么去掉rRNA。  测序的概念 双端测序涉及到两端的转换。补个截图增强理解。</description>
    </item>
    
    <item>
      <title>Shell：使用数组</title>
      <link>/blog/shell-array/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/shell-array/</guid>
      <description>之前使用Shell编程很少使用到数组，最近尝试使用后发现它在某些情况下非常有用。 这里简单介绍如何生成和使用数组。
生成数组 我们只要将一组空格分隔的序列用括号括起来，就生成了一个数组。
1array=(a b c d e f g) 使用数组 输出数组 使用${array[*]}或${array[@]}输出全部元素：
1bash-3.2$ echo ${array[*]} 2a b c d e f g 3bash-3.2$ echo ${array[@]} 4a b c d e f g 在array前加#输出元素个数：
1bash-3.2$ echo ${#array[*]} 27 获取元素将*改成索引，记得是从0开始：
1bash-3.2$ echo ${array[1]} 2b 3bash-3.2$ echo ${array[2]} 4c 注意在非引用的情况下不需要美元符号和花括号，例如修改元素：
1bash-3.2$ array[2]=ff 2bash-3.2$ echo ${array[2]} 3ff 迭代数组：
1#for i in &amp;amp;#34;${!array[@]}&amp;amp;#34;; do  2# printf &amp;amp;#34;%s\t%s\n&amp;amp;#34; &amp;amp;#34;$i&amp;amp;#34; &amp;amp;#34;${array[$i]}&amp;amp;#34; 3#done 4 5bash-3.2$ for i in &amp;amp;#34;${!</description>
    </item>
    
    <item>
      <title>关于区间突变概率计算理解的纠正</title>
      <link>/blog/adjustment-for-mutaiton-prob-in-a-region/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/adjustment-for-mutaiton-prob-in-a-region/</guid>
      <description>资料来源：https://www.huber.embl.de/msmb/Chap-Generative.html，我把资料中的情景更改了下。
 假设50个样本有100个碱基，单个位点有百分之一的突变率，汇总50个样本，我们期望在任何给定位置，50个样本观测到突变次数的总和服从具有参数为0.5的泊松分布。
一个随机的图如下：
现在让我们假设实际观测的图如下：
这种情况的概率是多少呢？
让我们先看一下至少出现7次的概率： $$ \begin{equation*} P(X\geq 7)= \sum_{k=7}^\infty P(X=k). \end{equation*} $$ 它可以转变为1减去出现少于7次的概率。
在R里面可以计算：
我们假设我们最后要计算得到的概率为$\epsilon$： $$ \begin{equation*} \epsilon=P(X\geq 7)=1-P(X\leq 6)\simeq10^{-6}. \end{equation*} $$
停！上面是错误的计算！
上面我们看了100个位置，寻找最大值并发现它是7，这种情况下出现7的概率比单个位置出现7的概率要大！
这里我们使用极端值分析，先对每个位置出现的次数排序，然后重新命名。
那么最大值出现至少7次的概率可以采用互补计算： $$ \begin{equation*} \begin{aligned} P(x_{(100)}\geq 7) &amp;amp;amp;=&amp;amp;amp;1-P(x_{(100)} \leq 6)\\
&amp;amp;amp;=&amp;amp;amp;1-P(x_{(1)}\leq 6 )\times P(x_{(2)}\leq 6 )\times \cdots \times P(x_{(100)} \leq 6 )\\
&amp;amp;amp;=&amp;amp;amp;1-P(x_1\leq 6 )\times P(x_2\leq 6 )\times \cdots \times P(x_{100}\leq 6 )\\
&amp;amp;amp;=&amp;amp;amp;1-\prod_{i=1}^{100} P(x_i \leq 6 ).\end{aligned} \end{equation*} $$ 由于100个事件是独立的，所以转换为： $$ \begin{equation*} \prod_{i=1}^{100} P(x_i \leq 6)= \left(P(x_i \leq 6)\right)^{100}= \left(1-\epsilon\right)^{100}.</description>
    </item>
    
    <item>
      <title>深度学习数学基础</title>
      <link>/blog/math-basics-for-dl/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/math-basics-for-dl/</guid>
      <description>本文来自《动手学习深度学习》附录。很久之前就摘录了，总觉得某一天用得上，不厌其烦地搬运了。 参考https://blog.csdn.net/xm_ovo/article/details/107536132一文对公式进行了正确的换行处理，以保持与简书相同的阅读效果。
  本文总结了本书中涉及的有关线性代数、微分和概率的基础知识。
线性代数 下面分别概括了向量、矩阵、运算、范数、特征向量和特征值的概念。
向量 本书中的向量指的是列向量。一个$n$维向量$\boldsymbol{x}$的表达式可写成
$$ \boldsymbol{x} = \begin{bmatrix} x_{1} \\
x_{2} \\
\vdots \\
x_{n} \end{bmatrix}, $$
其中$x_1, \ldots, x_n$是向量的元素。我们将各元素均为实数的$n$维向量$\boldsymbol{x}$记作$\boldsymbol{x} \in \mathbb{R}^{n}$或$\boldsymbol{x} \in \mathbb{R}^{n \times 1}$。
矩阵 一个$m$行$n$列矩阵的表达式可写成
$$ \boldsymbol{X} = \begin{bmatrix} x_{11} &amp;amp;amp; x_{12} &amp;amp;amp; \dots &amp;amp;amp; x_{1n} \\
x_{21} &amp;amp;amp; x_{22} &amp;amp;amp; \dots &amp;amp;amp; x_{2n} \\
\vdots &amp;amp;amp; \vdots &amp;amp;amp; \ddots &amp;amp;amp; \vdots \\
x_{m1} &amp;amp;amp; x_{m2} &amp;amp;amp; \dots &amp;amp;amp; x_{mn} \end{bmatrix}, $$</description>
    </item>
    
    <item>
      <title>ggplot构建新图形元素</title>
      <link>/blog/ggplot-build-new-object/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot-build-new-object/</guid>
      <description>2021/05/24 19:35
 原文：https://bookdown.org/rdpeng/RProgDA/building-new-graphical-elements.html
 由ggplot构造的数据图中的关键元素包括geoms（几何对象）和stats（统计变换）。事实上，ggplot2包具有强大的功能，允许用户制作各种有趣而丰富的数据图形。这些图形可以通过组合调用各种geom_*和stat_*函数(以及其他类函数)来实现。
为什么要构造新的图形元素？
  实现ggplot2目前不存在的特性。
  简化复杂的工作流。如果你总是发现自己在用重复的代码绘制类似的图形元素。
  创建新的geoms和stats可以简化代码，让用户轻松调整情节的某些元素，而不必每次都费劲地处理整个代码。
构造一个geom ggplot2中的新geoms继承自一个名为Geom的顶级类，并使用两步流程构造：
  ggproto()函数用于构造一个与新的geom对应的新类。这个新类指定了许多属性和函数，这些属性和函数描述了如何在图上绘制数据。
  geom_*函数被构造为标准函数。这个函数返回一个层，该层可以添加到使用ggplot()函数创建的plot中。
  新的geom类的基本设置如下所示：
1GeomNEW &amp;amp;lt;- ggproto(&amp;amp;#34;GeomNEW&amp;amp;#34;, Geom, 2 required_aes = &amp;amp;lt;a character vector of required aesthetics&amp;amp;gt;, 3 default_aes = aes(&amp;amp;lt;default values for certain aesthetics&amp;amp;gt;), 4 draw_key = &amp;amp;lt;a function used to draw the key in the legend&amp;amp;gt;, 5 draw_panel = function(data, panel_scales, coord) { 6 ## 返回一个grid grob对象的函数 7 ## 是绘图真正工作的地方 8 } 9) 所需的美学映射应该很简单——例如，如果你的新geom生成了一种特殊的散点图，那么你可能需要x和y映射。美学映射的默认值可以包括绘图符号如形状、颜色等内容。</description>
    </item>
    
    <item>
      <title>grid 1：图形对象grobs</title>
      <link>/blog/grobs/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grobs/</guid>
      <description>学习材料：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#grobs
grobs 是 grid 绘图系统中图形对象的表示，即 graphics &#43; objects = grobs
grobs 的创建通常使用以 Grob 作为后缀的函数们，包括circleGrob, linesGrob, polygonGrob, rasterGrob, rectGrob, segmentsGrob, legendGrob, xaxisGrob, and yaxisGrob 等等。 gridExtra 包定义了更多的图形对象。
下面是一个绘圆的示例：
1library(grid) 2my_circle &amp;amp;lt;- circleGrob(x = 0.5, y = 0.5, r = 0.5, 3 gp = gpar(col = &amp;amp;#34;gray&amp;amp;#34;, lty = 3)) 每个图形对象有自带的参数，比如圆有它的中心，半径。而不同的对象有相同的一些参数设定，包括颜色、线型、大小等等，这通过 gpar 函数进行设定。
再创建图形对象后，使用 grid.draw() 将图形绘制出来。
1grid.draw(my_circle) 多个图形对象可以叠加，而且叠加后可以修改原来的图形对象。
1my_circle &amp;amp;lt;- circleGrob(name = &amp;amp;#34;my_circle&amp;amp;#34;, 2 x = 0.5, y = 0.5, r = 0.</description>
    </item>
    
    <item>
      <title>grid 2：视图 viewports</title>
      <link>/blog/viewports/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/viewports/</guid>
      <description>原文：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#viewports
 视图是什么 视图是绘图窗口，我们可以将其移进或移出，以方便使用grid包定制绘图。我们可以导航到其中一个视图，进行一些更改，然后弹出并导航到另一个视图。简而言之，视图提供了一种在绘图（可以想象为一个画板）的不同子空间（不同的层，如果了解ggplot2，采用图层概念理解它）中导航和工作的方法。
下面是一个例子，我们在整个图形的右上角绘制一个棒棒图：
1# 默认，grid会初始化第一个视图 2grid.draw(rectGrob()) 3# 创建一个小的视图 4# 指定新视图的位置，X为0.5，Y为0.5，视图高宽都为0.5 5sample_vp &amp;amp;lt;- viewport(x = 0.5, y = 0.5, 6 width = 0.5, height = 0.5, 7 just = c(&amp;amp;#34;left&amp;amp;#34;, &amp;amp;#34;bottom&amp;amp;#34;)) # 位置校正参数 8# 导航视图：上面只是定义了一个视图对象 9# 我们可以想象为一个大画板是一张白纸 10# 我们上面准备了一张小的白纸 11# 而 push 的目的就是把小的白纸放到大白纸的对应位置 12# 接下来的绘图动作就是在小的白纸上进行的 13pushViewport(sample_vp) 14grid.draw(roundrectGrob()) 15grid.draw(lollipop) 16# 弹出最上层的视图 17popViewport()  棒棒图的绘制见「R」grid 图形对象 grobs一文末尾。
 视图的just参数 值得注意的是这里的just参数：它定义了新的视图是如何在旧（大） 的视图上摆放的。这里的c(&amp;amp;quot;left&amp;amp;quot;, &amp;amp;quot;bottom&amp;amp;quot;)指定了小的视图的左侧和下侧与其坐标单位0.5, 0.5对齐。我们看看修改下该参数的效果：
1grid.draw(rectGrob()) 2sample_vp &amp;amp;lt;- viewport(x = 0.5, y = 0.</description>
    </item>
    
    <item>
      <title>grid 3：图形坐标系统</title>
      <link>/blog/coords/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/coords/</guid>
      <description>绘图时，我们需要坐标才能准确地对要绘制的对象进行定位。在 grid 包中，有多种绘图坐标系统，选择一个合适的加以利用可以帮助我们更好地绘制图形。
坐标系统不同的单位：
  native 单位：根据数据值。
  n pc单位：将整个（笛卡尔）坐标系缩放为0到1范围。
  实际尺寸单位：包括英寸、厘米、毫米。
  例如，下面的绘图同时用到了前两者：
1ex_vp &amp;amp;lt;- viewport(x = 0.5, y = 0.5, # npc 单位 2 just = c(&amp;amp;#34;center&amp;amp;#34;, &amp;amp;#34;center&amp;amp;#34;), 3 height = 0.8, width = 0.8, 4 xscale = c(0, 100), yscale = c(0, 10)) # 设定native单位 5pushViewport(ex_vp) 6grid.draw(rectGrob()) 7grid.draw(circleGrob(x = unit(20, &amp;amp;#34;native&amp;amp;#34;), y = unit(5, &amp;amp;#34;native&amp;amp;#34;), # 根据native单位绘图 8 r = 0.1, gp = gpar(fill = &amp;amp;#34;lightblue&amp;amp;#34;))) 9grid.</description>
    </item>
    
    <item>
      <title>grid 4：gridExtra包</title>
      <link>/blog/grid-4-gridextra%E5%8C%85/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grid-4-gridextra%E5%8C%85/</guid>
      <description>gridExtra包提供了grid系统的有用拓展，包括对grobs对象的操作方法和其他一些grobs对象。
grid.arrange()可以绘制多个对象：
1library(gridExtra) 2grid.arrange(lollipop, circleGrob(), 3 rectGrob(), lollipop, 4 ncol = 2) 由于ggplot2也是基于grid系统的，所以我们可以使用该函数对ggplot对象组合排序：
1time_vs_shots &amp;amp;lt;- ggplot(worldcup, aes(x = Time, y = Shots)) &#43; 2 geom_point() 3player_positions &amp;amp;lt;- ggplot(worldcup, aes(x = Position)) &#43; 4 geom_bar() 5 6grid.arrange(time_vs_shots, player_positions, ncol = 2) 使用layout_matrix选项可以进行更自定义控制：
1grid.arrange(time_vs_shots, player_positions, 2 layout_matrix = matrix(c(1, 2, 2), ncol = 3)) 包括图形填充：
1grid.arrange(time_vs_shots, player_positions, 2 layout_matrix = matrix(c(1, NA, NA, NA, 2, 2), 3 byrow = TRUE, ncol = 3)) 使用tableGrob()函数，我们可以在图中嵌入表格。下面是一个略微复杂的例子：</description>
    </item>
    
    <item>
      <title>Rcpp：数据结构</title>
      <link>/blog/rcpp-data-structure/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-data-structure/</guid>
      <description>RObject类 RObject类在Rcpp类系统中占核心地位。虽然它不是面向用户的，但为接下来的所有类提供了公共的数据结构，它是构建Rcpp API的基础类。
每一个RObject类实例都封装了一个R对象，而每个对象在内部可以表示为一个SEXP：一个指向S表达式对象的指针。
基于它的用户可见（可使用）的类：
  IntegerVector对应整型向量。
  NumericVector对应数值向量。
  LogicalVector对应逻辑值向量。
  CharacterVector对应Character向量。
  GenericVector对应List类型的泛型向量。
  ExpressionVector对应表达式类型向量。
  RawVector对应raw类型向量。
  对于整型和数值型，我们还有IntegerMatrix和NumericMatrix对应R中的数值矩阵。
下面我们通过整型向量来了解它们。
IntegerVector类 模板函数as&amp;amp;lt;&amp;amp;gt;()用于从R转换到C&#43;&#43;，而wrap()函数的方向相反。
 实际大多数使用情况下，我们已经不需要显式地进行转换处理，该过程会在底层自动完成。
 示例：返回完美数 什么是完美数：
https://baike.baidu.com/item/完全数/370913?fromtitle=完美数&amp;amp;amp;fromid=871560&amp;amp;amp;fr=aladdin
代码：
1library(Rcpp) 2library(inline) 3 4src &amp;amp;lt;- &amp;amp;#39; 5Rcpp::IntegerVector epn(4); 6epn[0] = 6; 7epn[1] = 14; 8epn[2] = 496; 9epn[3] = 8182; 10return epn; 11&amp;amp;#39; 12 13func &amp;amp;lt;- cxxfunction(signature(), src, plugin = &amp;amp;#34;Rcpp&amp;amp;#34;) 调用：</description>
    </item>
    
    <item>
      <title>Unix：Bash编程</title>
      <link>/blog/unix-bash-programming/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-bash-programming/</guid>
      <description>原文：https://seankross.com/the-unix-workbench/bash-programming.html
 数学 创建math.sh：
1#!/usr/bin/env bash 2# File: math.sh 3 4expr 5 &#43; 2 5expr 5 - 2 6expr 5 \* 2 # 转义 7expr 5 / 2 保存然后运行：
1$ bash math.sh 27 33 410 52 ⚠️注意，bash使用整除法。求余使用%符号。
如果我们想要进行更为复杂的数学计算，使用bc命令。
创建文件bigmath.sh：
1#!/usr/bin/env bash 2# File: bigmath.sh 3 4echo &amp;amp;#34;22 / 7&amp;amp;#34; | bc -l 5echo &amp;amp;#34;4.2 * 9.15&amp;amp;#34; | bc -l 6echo &amp;amp;#34;(6.5 / 0.5) &#43; (6 * 2.2)&amp;amp;#34; | bc -l 结果：</description>
    </item>
    
    <item>
      <title>Unix：Make</title>
      <link>/blog/unix-make/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-make/</guid>
      <description>2021/05/26 22:01
 原文：https://seankross.com/the-unix-workbench/working-with-unix.html#make
 从前没有网页浏览器、文件浏览器、开始菜单或搜索栏。当有人启动电脑时，他们得到的是一个shell提示符，他们做的所有工作都是从这个提示符开始的。那时候，人们仍然喜欢共享软件，但总是存在软件应该如何安装的问题。make程序是解决这个问题的最好的尝试，make的优雅使它至今仍被广泛使用。make的指导设计目标是为了安装一些新软件:
  将所有的依赖下载到一个目录。
  cd进入目录。
  运行make。
  这是通过指定一个名为makefile的文件来实现的，该文件描述了不同文件和程序之间的关系 。除了安装程序之外，make对于自动创建文档也很有用。让我们构建一个makefile，它创建一个readme.txt文件，该文件自动填充有关当前目录的一些信息。
首先进入目录并创建一个文件：
1▶ cd ~/Documents/test 2▶ nano makefile 填入如下内容：
1draft_journal_entry.txt: 2 touch draft_journal_entry.txt 上面简单的makefile说明了一个规则，它的一般格式如下：
1[target]: [dependencies...] 2 [commands...] 在这个简单的示例中，我们创建了以draft_journal_entry.txt为目标的文件，该文件是作为命令的结果创建的。需要注意的是，目标下的任何命令都必须用Tab缩进。如果我们不使用Tab 来缩进命令，那么make将失败。让我们保存并关闭makefile，然后我们可以在控制台中运行以下命令：
1▶ ls 2makefile 然后使用下面的操作查看make使用方式：
1▶ make draft_journal_entry.txt 2touch draft_journal_entry.txt 3▶ ls 4draft_journal_entry.txt makefile 在我们为draft_journal_entry.txt目标定义的规则下缩进的命令已经执行，所以现在draft_journal_entry.txt存在！让我们再次运行相同的make命令：
1▶ make draft_journal_entry.txt 2make: `draft_journal_entry.txt&amp;amp;#39; is up to date. 因为目标文件已经存在，所以没有采取任何操作，相反，我们被告知，draft_journal_entry.txt的规则是“最新的”(没有什么需要做的)。
如果我们看一下我们之前草拟的一般规则格式，我们可以看到我们没有为该规则指定任何依赖项。依赖项是目标在构建时所依赖的文件。如果自上次为目标运行make以来，依赖项已经更新，则目标不是“最新的”。这意味着下次为该目标运行make时将运行该目标的命令。通过这种方式，对依赖项的更改被合并到目标中。为了避免不必要地运行命令，这些命令只在依赖项改变时运行，或者当目标根本不存在时运行。
让我们更新makefile，以包含自动生成的readme.txt。首先，让我们添加文件：
1▶ echo &amp;amp;#34;1. 2017-06-15-In-Boston&amp;amp;#34; &amp;amp;gt; toc.txt makefile修改为：</description>
    </item>
    
    <item>
      <title>使用Circle-Map Realign鉴定环形DNA</title>
      <link>/blog/use-circle-map-for-detecting-eccdna/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-circle-map-for-detecting-eccdna/</guid>
      <description>2021/07/23 19:39
 原文：https://github.com/iprada/Circle-Map/wiki/Tutorial:-Identification-of-circular-DNA-using-Circle-Map-Realign
 这是一个教程，一步一步地解释如何从原始数据(fastq文件)到一个可解释的，标签分离的bed文件指示染色体坐标的DNA环。为了制作教程，我们模拟了Illumina读取来自人类基因组未知区域的环形DNA。本教程的目的是使用Circle-Map来提取环形DNA的来源。
依赖   GNU/Linux
  BWA
  samtools
  Circle-Map
  1conda install -c bioconda bwa samtools 2pip3 install Circle-Map 3pip3 install biopython==1.77 # 不安装这个版本目前使用会报错 4 第一步：准备和下载数据 下载原始数据 直接克隆仓库：
1git clone https://github.com/iprada/Circle-Map 下载和准备参考基因组 1wget http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz 2gunzip -d hg38.fa.gz 3 4bwa index hg38.fa 5samtools faidx hg38.fa 6 第二步：比对到参考基因组 1cd Circle-Map/tutorial/ 2bwa mem -q ~/data/refs/hg38.fa unknown_circle_reads_1.fastq unknown_circle_reads_2.fastq &amp;amp;gt; unknown_circle.sam 3 这就产生了一个SAM文件，其中包含了关于reads在哪里以及如何与基因组对齐的信息。
  我们使用 -q 选项（query name sorted）为BWA中的拆分读对比对分配独立的映射质量分数 。这可以改进Circle-Map概率模型中断点图权值的估计。</description>
    </item>
    
    <item>
      <title>Jupyter Notebook 插件配置</title>
      <link>/blog/jupyter-notebook-plugin-configs/</link>
      <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/jupyter-notebook-plugin-configs/</guid>
      <description>安装命令：
1pip3 install -U jupyter_contrib_nbextensions 2jupyter contrib nbextension install --user 3pip3 install -U jupyter_nbextensions_configurator 4jupyter nbextensions_configurator enable --user 5 6pip3 install -U qgrid # 动态操作 DataFrame 7jupyter nbextension enable --py --sys-prefix qgrid 8jupyter nbextension enable --py --sys-prefix widgetsnbextension 如果要修改主题：
1pip3 install -U jupyterthemes 网址：https://github.com/dunovank/jupyter-themes
激活的插件：</description>
    </item>
    
    <item>
      <title>Slurm使用技巧</title>
      <link>/blog/slurm-tricks/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/slurm-tricks/</guid>
      <description>Slurm的官方文档在：https://slurm.schedmd.com/。
这篇文章记录下我在工作中使用经常用到，但是一般的初级文档不会涉及的内容、操作。
系统节点资源概览 一般我们输入sinfo，只能看到非常精简的节点信息：
1$ sinfo 2PARTITION AVAIL TIMELIMIT NODES STATE NODELIST 3cn up infinite 1 mix cn03 4cn up infinite 2 alloc cn[01-02] 5cn up infinite 15 idle cn[04-18] 6fat up infinite 1 idle fat01 7gpu* up infinite 1 idle gpu01 我们可以添加几个选项来获得一个更为完备的信息：
1$ sinfo -Nel 2Fri Aug 6 15:54:17 2021 3NODELIST NODES PARTITION STATE CPUS S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE REASON 4cn01 1 cn allocated 80 80:1:1 771000 0 1 (null) none 5cn02 1 cn allocated 80 80:1:1 771000 0 1 (null) none 6cn03 1 cn mixed 80 80:1:1 771000 0 1 (null) none 7cn04 1 cn idle 80 80:1:1 771000 0 1 (null) none 8cn05 1 cn idle 80 80:1:1 771000 0 1 (null) none 9cn06 1 cn idle 80 80:1:1 771000 0 1 (null) none 10cn07 1 cn idle 80 80:1:1 771000 0 1 (null) none 11cn08 1 cn idle 80 80:1:1 771000 0 1 (null) none 12cn09 1 cn idle 80 80:1:1 771000 0 1 (null) none 13cn10 1 cn idle 80 80:1:1 771000 0 1 (null) none 14cn11 1 cn idle 80 80:1:1 771000 0 1 (null) none 15cn12 1 cn idle 80 80:1:1 771000 0 1 (null) none 16cn13 1 cn idle 80 80:1:1 771000 0 1 (null) none 17cn14 1 cn idle 80 80:1:1 771000 0 1 (null) none 18cn15 1 cn idle 80 80:1:1 771000 0 1 (null) none 19cn16 1 cn idle 80 80:1:1 771000 0 1 (null) none 20cn17 1 cn idle 80 80:1:1 771000 0 1 (null) none 21cn18 1 cn idle 80 80:1:1 771000 0 1 (null) none 22fat01 1 fat idle 80 80:1:1 296649 0 1 (null) none 23gpu01 1 gpu* idle 40 40:1:1 772000 0 1 (null) none 全部的选项介绍在文档sinfo中。</description>
    </item>
    
    <item>
      <title>LeetCode：0001-两数之和</title>
      <link>/blog/leetcode-0001-two-sum/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/leetcode-0001-two-sum/</guid>
      <description>难度：简单。
参考：
  https://leetcode-cn.com/problems/two-sum
  https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0001.Two-Sum/
  代码仓库：https://github.com/ShixiangWang/LeetCode
问题 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出 和为目标值target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
示例：
1输入：nums = [2,7,11,15], target = 9 2输出：[0,1] 3解释：因为 nums[0] &#43; nums[1] == 9 ，返回 [0, 1] 。 题解 顺序扫描数组，对每一个元素，在map中找能组合给定值的另一半数字，如果找到了，直接返回2个数字的下标即可。如果找不到，就把这个数字存入map中，等待扫到“另一半”数字的时候，再取出来返回结果。
这种解法将数据扫描一遍必然得到结果，所以时间复杂度是O(n)。
Go 1package main 2 3import &amp;amp;#34;fmt&amp;amp;#34; 4 5func twoSum(nums []int, target int) []int { 6 m := make(map[int]int) 7 for i := 0; i &amp;amp;lt; len(nums); i&#43;&#43; { 8 another := target - nums[i] 9 if _, ok := m[another]; ok { 10 return []int{m[another], i} 11 } 12 m[nums[i]] = i 13 } 14 return nil 15} 16 17func main() { 18 fmt.</description>
    </item>
    
    <item>
      <title>旧文存档</title>
      <link>/blog/blog-archives/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/blog-archives/</guid>
      <description> GitHub Home 博客：https://shixiangwang.github.io/home 语雀：https://www.yuque.com/shixiangwang 我来：https://www.wolai.com/sCHoE8HyUFnDEuCrth7PZG  </description>
    </item>
    
    <item>
      <title>RMarkdown template from my reference blog</title>
      <link>/blog/questions-answers-and-reprexes/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/questions-answers-and-reprexes/</guid>
      <description>I stumbled into a niche YouTube genre: Web Development online instructors (a.k.a content creators) challenge each other to “CSS Battles”.
Turns out they are fascinating videos where experienced programmers talk and fumble their way through their coding.
As they talked through their thought processes, I thought about the questions we ask when our code goes wrong and the answers we get when we reprex.
 CSS Battle with The CSS King     I challenged The CSS King to a CSS Battle on YouTube   I’ve thought a lot about this video since I watched it.</description>
    </item>
    
  </channel>
</rss>