<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on ShixiangWang
王诗翔</title>
    <link>/categories/blog/</link>
    <description>Recent content in Blog on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RNAseq原理与分析课程笔记</title>
      <link>/blog/rnaseq-cource-notes/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rnaseq-cource-notes/</guid>
      <description>很久之前在腾讯课堂购买了孟浩巍的RNAseq课程，讲解的挺细致完备的。这里主要是很少做这样的分析，所以一方面扫盲，一方面记录下其中重要的点（自己不知道的）或者值得拓展了解的知识点。
参考基因组与基因分布 拼装失败的地方大都是rRNA位置区域，与后面的内容对应。
rRNA 这里有几个点：
 一个DNA分子是比一个氨基酸大的 rRNA是集中分布的 rRNA在全部RNA中的占比很高，达80%左右。所以mRNA测序要么富集poly-A，要么去掉rRNA。  测序的概念 双端测序涉及到两端的转换。补个截图增强理解。</description>
    </item>
    
    <item>
      <title>Shell：使用数组</title>
      <link>/blog/shell-array/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/shell-array/</guid>
      <description>之前使用Shell编程很少使用到数组，最近尝试使用后发现它在某些情况下非常有用。 这里简单介绍如何生成和使用数组。
生成数组 我们只要将一组空格分隔的序列用括号括起来，就生成了一个数组。
1array=(a b c d e f g) 使用数组 输出数组 使用${array[*]}或${array[@]}输出全部元素：
1bash-3.2$ echo ${array[*]} 2a b c d e f g 3bash-3.2$ echo ${array[@]} 4a b c d e f g 在array前加#输出元素个数：
1bash-3.2$ echo ${#array[*]} 27 获取元素将*改成索引，记得是从0开始：
1bash-3.2$ echo ${array[1]} 2b 3bash-3.2$ echo ${array[2]} 4c 注意在非引用的情况下不需要美元符号和花括号，例如修改元素：
1bash-3.2$ array[2]=ff 2bash-3.2$ echo ${array[2]} 3ff 迭代数组：
1#for i in &amp;#34;${!array[@]}&amp;#34;; do  2# printf &amp;#34;%s\t%s\n&amp;#34; &amp;#34;$i&amp;#34; &amp;#34;${array[$i]}&amp;#34; 3#done 4 5bash-3.2$ for i in &amp;#34;${!</description>
    </item>
    
    <item>
      <title>关于区间突变概率计算理解的纠正</title>
      <link>/blog/adjustment-for-mutaiton-prob-in-a-region/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/adjustment-for-mutaiton-prob-in-a-region/</guid>
      <description>资料来源：https://www.huber.embl.de/msmb/Chap-Generative.html，我把资料中的情景更改了下。
 假设50个样本有100个碱基，单个位点有百分之一的突变率，汇总50个样本，我们期望在任何给定位置，50个样本观测到突变次数的总和服从具有参数为0.5的泊松分布。
一个随机的图如下：
现在让我们假设实际观测的图如下：
这种情况的概率是多少呢？
让我们先看一下至少出现7次的概率： $$ \begin{equation*} P(X\geq 7)= \sum_{k=7}^\infty P(X=k). \end{equation*} $$ 它可以转变为1减去出现少于7次的概率。
在R里面可以计算：
我们假设我们最后要计算得到的概率为$\epsilon$： $$ \begin{equation*} \epsilon=P(X\geq 7)=1-P(X\leq 6)\simeq10^{-6}. \end{equation*} $$
停！上面是错误的计算！
上面我们看了100个位置，寻找最大值并发现它是7，这种情况下出现7的概率比单个位置出现7的概率要大！
这里我们使用极端值分析，先对每个位置出现的次数排序，然后重新命名。
那么最大值出现至少7次的概率可以采用互补计算： $$ \begin{equation*} \begin{aligned} P(x_{(100)}\geq 7) &amp;amp;=&amp;amp;1-P(x_{(100)} \leq 6)\\
&amp;amp;=&amp;amp;1-P(x_{(1)}\leq 6 )\times P(x_{(2)}\leq 6 )\times \cdots \times P(x_{(100)} \leq 6 )\\
&amp;amp;=&amp;amp;1-P(x_1\leq 6 )\times P(x_2\leq 6 )\times \cdots \times P(x_{100}\leq 6 )\\
&amp;amp;=&amp;amp;1-\prod_{i=1}^{100} P(x_i \leq 6 ).\end{aligned} \end{equation*} $$ 由于100个事件是独立的，所以转换为： $$ \begin{equation*} \prod_{i=1}^{100} P(x_i \leq 6)= \left(P(x_i \leq 6)\right)^{100}= \left(1-\epsilon\right)^{100}.</description>
    </item>
    
    <item>
      <title>深度学习数学基础</title>
      <link>/blog/math-basics-for-dl/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/math-basics-for-dl/</guid>
      <description>本文来自《动手学习深度学习》附录。很久之前就摘录了，总觉得某一天用得上，不厌其烦地搬运了。 参考https://blog.csdn.net/xm_ovo/article/details/107536132一文对公式进行了正确的换行处理，以保持与简书相同的阅读效果。
  本文总结了本书中涉及的有关线性代数、微分和概率的基础知识。
线性代数 下面分别概括了向量、矩阵、运算、范数、特征向量和特征值的概念。
向量 本书中的向量指的是列向量。一个$n$维向量$\boldsymbol{x}$的表达式可写成
$$ \boldsymbol{x} = \begin{bmatrix} x_{1} \\
x_{2} \\
\vdots \\
x_{n} \end{bmatrix}, $$
其中$x_1, \ldots, x_n$是向量的元素。我们将各元素均为实数的$n$维向量$\boldsymbol{x}$记作$\boldsymbol{x} \in \mathbb{R}^{n}$或$\boldsymbol{x} \in \mathbb{R}^{n \times 1}$。
矩阵 一个$m$行$n$列矩阵的表达式可写成
$$ \boldsymbol{X} = \begin{bmatrix} x_{11} &amp;amp; x_{12} &amp;amp; \dots &amp;amp; x_{1n} \\
x_{21} &amp;amp; x_{22} &amp;amp; \dots &amp;amp; x_{2n} \\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
x_{m1} &amp;amp; x_{m2} &amp;amp; \dots &amp;amp; x_{mn} \end{bmatrix}, $$</description>
    </item>
    
    <item>
      <title>ggplot构建新图形元素</title>
      <link>/blog/ggplot-build-new-object/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot-build-new-object/</guid>
      <description>2021/05/24 19:35
 原文：https://bookdown.org/rdpeng/RProgDA/building-new-graphical-elements.html
 由ggplot构造的数据图中的关键元素包括geoms（几何对象）和stats（统计变换）。事实上，ggplot2包具有强大的功能，允许用户制作各种有趣而丰富的数据图形。这些图形可以通过组合调用各种geom_*和stat_*函数(以及其他类函数)来实现。
为什么要构造新的图形元素？
  实现ggplot2目前不存在的特性。
  简化复杂的工作流。如果你总是发现自己在用重复的代码绘制类似的图形元素。
  创建新的geoms和stats可以简化代码，让用户轻松调整情节的某些元素，而不必每次都费劲地处理整个代码。
构造一个geom ggplot2中的新geoms继承自一个名为Geom的顶级类，并使用两步流程构造：
  ggproto()函数用于构造一个与新的geom对应的新类。这个新类指定了许多属性和函数，这些属性和函数描述了如何在图上绘制数据。
  geom_*函数被构造为标准函数。这个函数返回一个层，该层可以添加到使用ggplot()函数创建的plot中。
  新的geom类的基本设置如下所示：
1GeomNEW &amp;lt;- ggproto(&amp;#34;GeomNEW&amp;#34;, Geom, 2 required_aes = &amp;lt;a character vector of required aesthetics&amp;gt;, 3 default_aes = aes(&amp;lt;default values for certain aesthetics&amp;gt;), 4 draw_key = &amp;lt;a function used to draw the key in the legend&amp;gt;, 5 draw_panel = function(data, panel_scales, coord) { 6 ## 返回一个grid grob对象的函数 7 ## 是绘图真正工作的地方 8 } 9) 所需的美学映射应该很简单——例如，如果你的新geom生成了一种特殊的散点图，那么你可能需要x和y映射。美学映射的默认值可以包括绘图符号如形状、颜色等内容。</description>
    </item>
    
    <item>
      <title>grid 1：图形对象grobs</title>
      <link>/blog/grobs/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grobs/</guid>
      <description>学习材料：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#grobs
grobs 是 grid 绘图系统中图形对象的表示，即 graphics + objects = grobs
grobs 的创建通常使用以 Grob 作为后缀的函数们，包括circleGrob, linesGrob, polygonGrob, rasterGrob, rectGrob, segmentsGrob, legendGrob, xaxisGrob, and yaxisGrob 等等。 gridExtra 包定义了更多的图形对象。
下面是一个绘圆的示例：
1library(grid) 2my_circle &amp;lt;- circleGrob(x = 0.5, y = 0.5, r = 0.5, 3 gp = gpar(col = &amp;#34;gray&amp;#34;, lty = 3)) 每个图形对象有自带的参数，比如圆有它的中心，半径。而不同的对象有相同的一些参数设定，包括颜色、线型、大小等等，这通过 gpar 函数进行设定。
再创建图形对象后，使用 grid.draw() 将图形绘制出来。
1grid.draw(my_circle) 多个图形对象可以叠加，而且叠加后可以修改原来的图形对象。
1my_circle &amp;lt;- circleGrob(name = &amp;#34;my_circle&amp;#34;, 2 x = 0.5, y = 0.5, r = 0.</description>
    </item>
    
    <item>
      <title>grid 2：视图 viewports</title>
      <link>/blog/viewports/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/viewports/</guid>
      <description>原文：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#viewports
 视图是什么 视图是绘图窗口，我们可以将其移进或移出，以方便使用grid包定制绘图。我们可以导航到其中一个视图，进行一些更改，然后弹出并导航到另一个视图。简而言之，视图提供了一种在绘图（可以想象为一个画板）的不同子空间（不同的层，如果了解ggplot2，采用图层概念理解它）中导航和工作的方法。
下面是一个例子，我们在整个图形的右上角绘制一个棒棒图：
1# 默认，grid会初始化第一个视图 2grid.draw(rectGrob()) 3# 创建一个小的视图 4# 指定新视图的位置，X为0.5，Y为0.5，视图高宽都为0.5 5sample_vp &amp;lt;- viewport(x = 0.5, y = 0.5, 6 width = 0.5, height = 0.5, 7 just = c(&amp;#34;left&amp;#34;, &amp;#34;bottom&amp;#34;)) # 位置校正参数 8# 导航视图：上面只是定义了一个视图对象 9# 我们可以想象为一个大画板是一张白纸 10# 我们上面准备了一张小的白纸 11# 而 push 的目的就是把小的白纸放到大白纸的对应位置 12# 接下来的绘图动作就是在小的白纸上进行的 13pushViewport(sample_vp) 14grid.draw(roundrectGrob()) 15grid.draw(lollipop) 16# 弹出最上层的视图 17popViewport()  棒棒图的绘制见「R」grid 图形对象 grobs一文末尾。
 视图的just参数 值得注意的是这里的just参数：它定义了新的视图是如何在旧（大） 的视图上摆放的。这里的c(&amp;quot;left&amp;quot;, &amp;quot;bottom&amp;quot;)指定了小的视图的左侧和下侧与其坐标单位0.5, 0.5对齐。我们看看修改下该参数的效果：
1grid.draw(rectGrob()) 2sample_vp &amp;lt;- viewport(x = 0.5, y = 0.</description>
    </item>
    
    <item>
      <title>grid 3：图形坐标系统</title>
      <link>/blog/coords/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/coords/</guid>
      <description>绘图时，我们需要坐标才能准确地对要绘制的对象进行定位。在 grid 包中，有多种绘图坐标系统，选择一个合适的加以利用可以帮助我们更好地绘制图形。
坐标系统不同的单位：
  native 单位：根据数据值。
  n pc单位：将整个（笛卡尔）坐标系缩放为0到1范围。
  实际尺寸单位：包括英寸、厘米、毫米。
  例如，下面的绘图同时用到了前两者：
1ex_vp &amp;lt;- viewport(x = 0.5, y = 0.5, # npc 单位 2 just = c(&amp;#34;center&amp;#34;, &amp;#34;center&amp;#34;), 3 height = 0.8, width = 0.8, 4 xscale = c(0, 100), yscale = c(0, 10)) # 设定native单位 5pushViewport(ex_vp) 6grid.draw(rectGrob()) 7grid.draw(circleGrob(x = unit(20, &amp;#34;native&amp;#34;), y = unit(5, &amp;#34;native&amp;#34;), # 根据native单位绘图 8 r = 0.1, gp = gpar(fill = &amp;#34;lightblue&amp;#34;))) 9grid.</description>
    </item>
    
    <item>
      <title>grid 4：gridExtra包</title>
      <link>/blog/grid-4-gridextra%E5%8C%85/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grid-4-gridextra%E5%8C%85/</guid>
      <description>gridExtra包提供了grid系统的有用拓展，包括对grobs对象的操作方法和其他一些grobs对象。
grid.arrange()可以绘制多个对象：
1library(gridExtra) 2grid.arrange(lollipop, circleGrob(), 3 rectGrob(), lollipop, 4 ncol = 2) 由于ggplot2也是基于grid系统的，所以我们可以使用该函数对ggplot对象组合排序：
1time_vs_shots &amp;lt;- ggplot(worldcup, aes(x = Time, y = Shots)) + 2 geom_point() 3player_positions &amp;lt;- ggplot(worldcup, aes(x = Position)) + 4 geom_bar() 5 6grid.arrange(time_vs_shots, player_positions, ncol = 2) 使用layout_matrix选项可以进行更自定义控制：
1grid.arrange(time_vs_shots, player_positions, 2 layout_matrix = matrix(c(1, 2, 2), ncol = 3)) 包括图形填充：
1grid.arrange(time_vs_shots, player_positions, 2 layout_matrix = matrix(c(1, NA, NA, NA, 2, 2), 3 byrow = TRUE, ncol = 3)) 使用tableGrob()函数，我们可以在图中嵌入表格。下面是一个略微复杂的例子：</description>
    </item>
    
    <item>
      <title>Rcpp：数据结构</title>
      <link>/blog/rcpp-data-structure/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-data-structure/</guid>
      <description>RObject类 RObject类在Rcpp类系统中占核心地位。虽然它不是面向用户的，但为接下来的所有类提供了公共的数据结构，它是构建Rcpp API的基础类。
每一个RObject类实例都封装了一个R对象，而每个对象在内部可以表示为一个SEXP：一个指向S表达式对象的指针。
基于它的用户可见（可使用）的类：
  IntegerVector对应整型向量。
  NumericVector对应数值向量。
  LogicalVector对应逻辑值向量。
  CharacterVector对应Character向量。
  GenericVector对应List类型的泛型向量。
  ExpressionVector对应表达式类型向量。
  RawVector对应raw类型向量。
  对于整型和数值型，我们还有IntegerMatrix和NumericMatrix对应R中的数值矩阵。
下面我们通过整型向量来了解它们。
IntegerVector类 模板函数as&amp;lt;&amp;gt;()用于从R转换到C++，而wrap()函数的方向相反。
 实际大多数使用情况下，我们已经不需要显式地进行转换处理，该过程会在底层自动完成。
 示例：返回完美数 什么是完美数：
https://baike.baidu.com/item/完全数/370913?fromtitle=完美数&amp;amp;fromid=871560&amp;amp;fr=aladdin
代码：
1library(Rcpp) 2library(inline) 3 4src &amp;lt;- &amp;#39; 5Rcpp::IntegerVector epn(4); 6epn[0] = 6; 7epn[1] = 14; 8epn[2] = 496; 9epn[3] = 8182; 10return epn; 11&amp;#39; 12 13func &amp;lt;- cxxfunction(signature(), src, plugin = &amp;#34;Rcpp&amp;#34;) 调用：</description>
    </item>
    
  </channel>
</rss>
