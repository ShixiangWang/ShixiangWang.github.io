<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on ShixiangWang
王诗翔</title>
    <link>/categories/blog/</link>
    <description>Recent content in Blog on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 14 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解决conda报错：Module _sysconfigdata_x86_64_conda_linux_gnu not found</title>
      <link>/blog/conda-error-sysconfigdata-not-found/</link>
      <pubDate>Tue, 14 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/conda-error-sysconfigdata-not-found/</guid>
      <description>最新可能是受conda update conda的影响，发现使用conda涉及Python的操作时一直出现问题， 报错：
ModuleNotFoundError: No module named &amp;#39;_sysconfigdata_x86_64_conda_linux_gnu&amp;#39; 例如：
$ pip list Traceback (most recent call last): File &amp;#34;~/miniconda3/bin/pip&amp;#34;, line 7, in &amp;lt;module&amp;gt; from pip._internal.cli.main import main File &amp;#34;~/miniconda3/lib/python3.9/site-packages/pip/_internal/cli/main.py&amp;#34;, line 9, in &amp;lt;module&amp;gt; from pip._internal.cli.autocompletion import autocomplete File &amp;#34;~/miniconda3/lib/python3.9/site-packages/pip/_internal/cli/autocompletion.py&amp;#34;, line 10, in &amp;lt;module&amp;gt; from pip._internal.cli.main_parser import create_main_parser File &amp;#34;~/miniconda3/lib/python3.9/site-packages/pip/_internal/cli/main_parser.py&amp;#34;, line 8, in &amp;lt;module&amp;gt; from pip._internal.cli import cmdoptions File &amp;#34;~/miniconda3/lib/python3.9/site-packages/pip/_internal/cli/cmdoptions.py&amp;#34;, line 23, in &amp;lt;module&amp;gt; from pip._internal.cli.parser import ConfigOptionParser File &amp;#34;~/miniconda3/lib/python3.9/site-packages/pip/_internal/cli/parser.py&amp;#34;, line 12, in &amp;lt;module&amp;gt; from pip.</description>
    </item>
    
    <item>
      <title>Rcpp：什么时候使用Rcpp</title>
      <link>/blog/when-use-rcpp/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/when-use-rcpp/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/010_Rcpp_merit.html
什么时候使用  后面的迭代依赖于前面的迭代的循环操作。 需要访问向量/矩阵的每个元素。 在循环中循环调用函数。 动态更改向量的大小。 需要高级数据结构和算法的操作。  怎么配置 除了Windows需要安装Rtools，其他系统中一般已经装好了。
如果我们要自定义C++的配置，如更改编译器，需要使用到配置文件.R/Makevars。
下面是一个示例：
CC=/opt/local/bin/gcc-mp-4.7 CXX=/opt/local/bin/g++-mp-4.7 CPLUS_INCLUDE_PATH=/opt/local/include:$CPLUS_INCLUDE_PATH LD_LIBRARY_PATH=/opt/local/lib:$LD_LIBRARY_PATH CXXFLAGS= -g0 -O2 -Wall MAKE=make -j4  包括编译器位置、头文件位置、动态库位置、编译参数等。
 安装Rcpp install.packages(&amp;#34;Rcpp&amp;#34;) </description>
    </item>
    
    <item>
      <title>Rcpp：基本用法</title>
      <link>/blog/rcpp-basic-usage/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-basic-usage/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/030_basic_usage.html
使用Rcpp函数只需要3步：
 编写Rcpp源代码。 编译代码。 执行函数。  编写Rcpp代码 下面是一个对向量求和的Rcpp函数：
//sum.cpp #include &amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&amp;lt;v.length(); ++i){ sum += v[i]; } return(sum); } Rcpp函数定义格式 下面是定义一个Rcpp函数的基本格式：
#include&amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){ //do something  return RETURN_VALUE; }  #include&amp;lt;Rcpp.h&amp;gt;：这个句子允许你使用Rcpp包定义的类和函数。 // [[Rcpp::export]]：这个句子下面定义的函数可以从R中访问。 你需要把这个句子附加到你想从R中使用的每个函数中。 using namespace Rcpp;：这个句子是可选的。但是如果你没有写这个句子， 你必须添加前缀Rcpp::来指定由Rcpp定义的类和函数。(例如：Rcpp::NumericVector) RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}：你需要指定函数和参数的数据类型。 return RETURN_VALUE;：如果函数将返回一个值，return语句是强制性的。 然而，如果你的函数没有返回值（即RETURN_TYPE是无效的），返回语句可以省略。  编译代码 函数Rcpp::sourceCpp()将编译你的源代码，并将定义的函数加载到R。
library(Rcpp) sourceCpp(&amp;#39;sum.cpp&amp;#39;) 使用函数 像正常R函数一样调用它就可以了。</description>
    </item>
    
    <item>
      <title>在VSCode中使用ipython执行代码</title>
      <link>/blog/use-ipython-exe-code-in-vscode/</link>
      <pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-ipython-exe-code-in-vscode/</guid>
      <description>参考Stack Overflow这篇回答进行配置，将下面的内容加入settings.json.
&amp;#34;python.terminal.launchArgs&amp;#34;: [ &amp;#34;-m&amp;#34;, &amp;#34;IPython&amp;#34;, &amp;#34;--no-autoindent&amp;#34;, ], Python的数据科学社区都将编辑的重心放到了Jupyter notebook上，忽视了对.py文本本身的支持。 这个事情不知道是好是坏，但对于我这个R使用比较严重的人来说使用起来是不舒服的。 Jupyter的记录格式太笨重了，如果只是单独完成分析任务，代码加注释完全够用了。 R里面有RMarkdown格式，相比更加轻松。更重要的是，我在GitHub上2年前提的需求说 VSCode中Python文件不支持按块执行，现在也没有实现。只能找到上面的办法缓解这种不适。
我之前的帖子在：https://github.com/microsoft/vscode-python/issues/8851
我在issue中也看到了一些类似的提问和讨论，但皆不了了之。
其实还有一个痛点我没说，在执行完一句代码后，VSCode插件不会自动向下移动光标。
整个源代码编辑交互式分析的体验Python还没有编辑器能比过RStudio。</description>
    </item>
    
    <item>
      <title>云服务器清理病毒kdevtmpfsi</title>
      <link>/blog/clean-virus-in-cloud-server/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/clean-virus-in-cloud-server/</guid>
      <description>云服务器一段时间没使用就经常能发现存在挖矿病毒，也不知道怎么进来的。 也不知道各种云服务商干啥去了，一般能本地使用电脑还是不建议使用云服务器。
本文记录下清理病毒的大体流程，防止脑子总是忘记，又不是需要它。
查看占CPU任务名 这种一般top就可以了。
$ top -H top - 19:47:30 up 72 days, 4:01, 1 user, load average: 3.46, 3.17, 3.12 Threads: 357 total, 5 running, 352 sleeping, 0 stopped, 0 zombie %Cpu(s): 98.7 us, 1.3 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 1882016 total, 69388 free, 579844 used, 1232784 buff/cache KiB Swap: 2097148 total, 2002172 free, 94976 used. 1106516 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 24665 zd 20 0 710928 265496 672 R 98.</description>
    </item>
    
    <item>
      <title>mlr3（三）模型优化</title>
      <link>/blog/mlr3-model-optimization/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-model-optimization/</guid>
      <description>来源：https://mlr3book.mlr-org.com/optimization.html
模型优化
机器学习算法为其超参数设置了默认值。不管怎样，用户需要更改这些超参数，以在给定的数据集上实现最佳性能。不建议手动选择超参数值，因为这种方法很少能获得最佳性能。为了证实所选超参数（=调优）的有效性，建议进行数据驱动的优化。为了优化机器学习算法，必须指定（1）搜索空间，（2）优化算法(又称调优方法)，（3）评估方法，即重采样策略，（4）性能度量。
总而言之，关于调优的小节介绍：
 进行经验超参数选择 选择优化算法 简洁地指定搜索空间 触发调优 自动调优  本小节还需要包mlr3tuning，这是一个支持超参数调优的扩展包。
特征选择
本章的第二部分介绍特征选择，也称为变量选择。特征选择是寻找数据相关特征子集的过程。执行选择的一些原因：
 增强模型的可解释性 加速模型拟合 通过降低数据中的噪声来提高学习性能  在本文中，我们主要集中在最后一个方面。有不同的方法来识别相关的特征。在特征选择的分章中，我们强调了三种方法：
 运用过滤算法根据分数独立地选择特征 根据变量重要性过滤选择特征 包装器方法迭代地选择特性以优化性能度量  注意，过滤器不需要学习器。变量重要性过滤器需要一个学习器，该学习器在训练时可以计算特征的重要性值。获得的重要值可用于数据子集，然后可用于训练学习器。包装器方法可以用于任何学习器，但需要对学习器进行多次训练。
嵌套重采样
为了更好地估计泛化性能并避免数据泄漏，外部（性能）和内部（调优/特征选择）重采样过程都是必要的。本章将讨论以下特点：
 嵌套重采样中的内重采样和外重采样策略 嵌套重采样的执行 执行重采样迭代的评估  本小节将提供如何实现嵌套重采样的说明，包括mlr3中的内重采样和外重采样。
超参数调优 超参数是机器学习模型的二阶参数，虽然在模型估计过程中往往没有明确优化，但会对模型的结果和预测性能产生重要影响。通常，超参数在训练模型之前是固定的。但是，由于模型的输出可能对超参数的规范很敏感，因此通常建议对哪些超参数设置可以产生更好的模型性能做出明智的决定。在许多情况下，超参数设置可能是预先选择的，但在将模型拟合到训练数据上之前，尝试不同的设置可能是有利的。这个过程通常被称为模型“调优”。
超参数调优是通过mlr3tuning扩展包支持的。下面是这个过程的说明：
mlr3tuning的核心是R6类：
TuningInstanceSingleCrit，TuningInstanceMultiCrit：这两个类描述调优问题并存储结果。
Tuner：这个类是调优算法实现的基类。
TuningInstance* 类 下面的小节审查了皮马印度糖尿病数据集上的简单分类树的优化。
library(&amp;quot;mlr3verse&amp;quot;) task = tsk(&amp;quot;pima&amp;quot;) print(task) ## &amp;lt;TaskClassif:pima&amp;gt; (768 x 9) ## * Target: diabetes ## * Properties: twoclass ## * Features (8): ## - dbl (8): age, glucose, insulin, mass, pedigree, pregnant, pressure, ## triceps 我们使用rpart中的分类树，并选择我们想要调优的超参数的子集。这通常被称为“调优空间”。</description>
    </item>
    
    <item>
      <title>mlr3（二）基础</title>
      <link>/blog/mlr3-basics/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-basics/</guid>
      <description>来源：https://mlr3book.mlr-org.com/basics.html
本文将教你基本的mlr3知识，以及它的R6类和操作以用于机器学习。典型的机器学习工作流是这样的:
 Figure 1: 机器学习流程 source: https://mlr3book.mlr-org.com/images/ml_abstraction.svg  mlr3将数据封装在任务中，并将其分解为互不重叠的训练集和测试集。由于我们感兴趣的模型外推到新的数据，而不仅仅是记忆训练数据，独立的测试数据允许客观地评估模型的泛化。训练数据被提供给一个机器学习算法，在mlr3中我们称之为learner。learner利用训练数据建立输入特征与输出目标值之间关系的模型。然后使用该模型对测试数据进行预测，并将其与参考真值进行比较，以评估模型的质量。mlr3提供了许多不同的度量方法，根据预测值和实际值之间的差异来量化模型的执行情况。通常这是一个数字分数。
将数据分割为训练集和测试集、建立模型并对其进行评估的过程可能会重复多次，每次从原始数据中重新采样不同的训练集和测试集。多重重采样迭代允许我们对特定类型的模型获得更好、更一般化的性能估计，因为它是在不同的条件下测试的，而且由于数据重采样的特定方式，它不太容易产生偏差。
在许多情况下，这个简单的工作流不足以处理真实世界的数据，可能需要规范化（标准化）、缺失值的输入或特征选择。我们将在以后介绍更复杂的工作流程。
本文涵盖以下小主题：
任务：
任务用元信息封装数据，比如预测目标列的名称。我们将介绍如何：
 访问预定义的任务 指定一个任务类型 创建一个任务 使用任务的API工作 为任务的行和列分配角色 实施任务mutator 获取存储在任务中的数据  学习器
学习器封装机器学习算法来训练模型并对任务进行预测。它们由R和其他包提供。我们将介绍如何：
 访问随mlr3而来的分类和回归学习器集合，并检索特定的学习器 访问学习器的超参数值集并修改它们  如何修改和扩展学习器涵盖在补充高级技术部分。
训练和预测
关于训练和预测方法的部分说明了如何使用任务和学习器训练模型并对新数据集进行预测。特别地，我们将介绍如何：
 正确设置任务和学习器 为一项任务设置训练和测试分割（集） 在训练集上训练学习器以生成模型 生成测试集的预测 通过比较预测值和实际值来评估模型的性能  重采样
重采样是一种创建训练和测试分割（集）的方法。我们将介绍：
 访问和选择重采样策略 通过应用重采样实例化分割到训练集和测试集 执行重采样以获得结果  关于重采样的附加信息可以在嵌套重采样部分和模型优化一章中找到。
基准测试
基准测试用于比较不同模型的性能，例如不同学习器训练的模型，不同任务训练的模型，或不同重采样方法训练的模型。我们介绍如何
 创建一个基准设计 执行设计并汇总结果 将基准测试对象转换为重采样对象  二分类
二值分类是分类的一种特殊情况，预测的目标变量只有两个可能的值。在这种情况下，还需要考虑其他因素。特别是：
 ROC曲线和预测一个类和另一个类的阈值 阈值调整  在详细介绍如何使用mlr3进行机器学习之前，我们先简要介绍一下R6，因为它是R相对较新的一部分。mlr3严重依赖于R6，它提供的所有基本构造都是R6类：
 任务 task 学习器 learner 测量 measure 重采样 resamplings  快速R6入门介绍 R6是R最新的面向对象编程(OO)方言之一。它解决了R中早期OO实现的缺点，比如我们在mlr中使用的S3。如果你以前做过面向对象编程，那么R6应该很熟悉。我们关注的是R6的部分，你需要知道在这里使用mlr3。</description>
    </item>
    
    <item>
      <title>R小技巧：分组应用和排序去重的应用与比较</title>
      <link>/blog/r-tricks-remove-duplicates-after-ordering/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/r-tricks-remove-duplicates-after-ordering/</guid>
      <description>问题与方案 假设我们有这样一个数据集：
df &amp;lt;- data.frame( c1 = c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), c2 = c(1, 3, 2, 1, 4, 2) ) df out c1 c2 out 1 a 1 out 2 a 3 out 3 a 2 out 4 b 1 out 5 b 4 out 6 c 2 如果我们想保留每个c1分类和分类下的最大值，你会怎么操作？
思考一分钟。
如果使用惯了tidyverse套装，我们脑子里容易冒出来的是这样的解法：使用分组应用。
library(dplyr) df |&amp;gt; group_by(c1) |&amp;gt; summarize(c2 = max(c2, na.rm = TRUE)) out # A tibble: 3 × 2 out c1 c2 out &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; out 1 a 3 out 2 b 4 out 3 c 2 在数据不是特别大的时候，使用这种策略没有任何问题。但如果分组有成千上万，分组的时间代价就很高了。有没有其他的方式可以解决该问题呢？</description>
    </item>
    
    <item>
      <title>forestmodel给多水平变量添加整体p值</title>
      <link>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</guid>
      <description>前段时间收到来信：
Hi Shixiang I am writing to you about the forestmodel package in R. Thank you so much for the wonderful package that you created. I was wondering if there is a way to display the wald test p-value which is important for variables that have more than two levels. I tried to work around the code but did not find a way out. Best Aniket 我不是作者，搞错了人，问我干啥呢～自个提问嘛
Hi Aniket, I am not the author of forestmodel, you can see from https://github.</description>
    </item>
    
    <item>
      <title>mlr3（一）快速入门</title>
      <link>/blog/mlr3-quickstart/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-quickstart/</guid>
      <description>来源：https://mlr3book.mlr-org.com/quickstart.html
安装包：
install.packages(&amp;quot;mlr3&amp;quot;) 作为一个30秒的介绍性示例，我们将在虹膜数据集的前120行训练决策树模型，并对最后30行进行预测，测量训练模型的准确性。
library(&amp;quot;mlr3&amp;quot;) task = tsk(&amp;quot;iris&amp;quot;) learner = lrn(&amp;quot;classif.rpart&amp;quot;) # 为任务的一个子集（前120行）训练这个学习器的模型 learner$train(task, row_ids = 1:120) # 决策树模型 learner$model ## n= 120 ## ## node), split, n, loss, yval, (yprob) ## * denotes terminal node ## ## 1) root 120 70 setosa (0.41666667 0.41666667 0.16666667) ## 2) Petal.Length&amp;lt; 2.45 50 0 setosa (1.00000000 0.00000000 0.00000000) * ## 3) Petal.Length&amp;gt;=2.45 70 20 versicolor (0.00000000 0.71428571 0.28571429) ## 6) Petal.</description>
    </item>
    
  </channel>
</rss>
