<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on ShixiangWang
(王诗翔)</title>
    <link>/categories/blog/</link>
    <description>Recent content in Blog on ShixiangWang
(王诗翔)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ggplot2在R包开发中的使用</title>
      <link>/blog/ggplot2-in-r-package/</link>
      <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot2-in-r-package/</guid>
      <description>没有特别系统的学习 tidy evaluation 这方面的高级操作，最近有空准备补一补，学习下这方面的知识。
原英文：https://github.com/tidyverse/ggplot2/blob/HEAD/vignettes/ggplot2-in-packages.Rmd
这篇文章是为在包代码中使用ggplot2的包开发人员准备的。在撰写本文时，ggplot2涉及在CRAN上的超过2,000个包和其他地方的更多包！在包中使用ggplot2编程增加了几个约束，特别是如果你想将包提交给CRAN。尤其是在R包中编程改变了从ggplot2引用函数的方式，以及在aes()和vars()中使用ggplot2的非标准求值的方式。
引用ggplot2函数与引用其他包类似，你需要在DESCRIPTION文件下的Imports条目下列出ggplot2，并使用::访问ggplot2提供的函数。（例如， ggplot2::function_name）：
mpg_drv_summary &amp;lt;- function() {ggplot2::ggplot(ggplot2::mpg) + ggplot2::geom_bar(ggplot2::aes(x = .data$drv)) + ggplot2::coord_flip()}如果你经常使用ggplot2，你可能希望将ggplot2的多个函数写入NAMESPACE文件。如果你使用roxygen2，那么你可以利用注释代码块 #&#39; @importFrom ggplot2 &amp;lt;one or more object names&amp;gt; （注意，这对数据集mpg不起作用）。
#&amp;#39; @importFrom ggplot2 ggplot aes geom_bar coord_flipmpg_drv_summary &amp;lt;- function() {ggplot(ggplot2::mpg) + geom_bar(aes(x = drv)) + coord_flip()}即使你的包里使用了很多的ggplot2函数，将ggplot2列入Depends条目或者将它整个导入NAMESPACE（例如，通过#&#39; @import ggplot2）都是不明智的。将ggplot2列入Depends会让你的包在被加载/测试的同时加载ggplot2。这会让其他想要使用你包的人通过::使用你的函数而无需加载它。同样地，导入ggplot2全部450个导出对象到你的命名空间会让分离你的包和ggplot2包的责任变得困难，特别是读者会搞不清这些函数到底来自哪里。
我个人碰到过很多这种情况。有时候在开发R包时为了保证正常运行，不得不将依赖包列入Depdens。实际上，如上所说，这一方面会让使用者懵逼，另一方面会造成开发病毒式感染，既不方便调试错误，想要使用你的包开发的人又不得不将你的包列入Depends。
在包函数中使用 aes() 和 vars()为了使用ggplot2创建图形，你很可能至少要使用一次aes()函数。如果你的图形使用了分面操作，你可能也会使用vars()用来指向绘图数据。而这两个函数都使用了非标准计算，如果你在包中直接使用它，后面再CMD check的使用会引入一个note。</description>
    </item>
    
    <item>
      <title>conda安装samtools包使用报错：libcrypto.so.1.0.0 not found</title>
      <link>/blog/conda-samtools-libcrypto-so-1-0-0-not-found/</link>
      <pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/conda-samtools-libcrypto-so-1-0-0-not-found/</guid>
      <description>通过conda的bioconda Channel安装samtools后，使用时发现报错。
(biosoft) wsx 11:55:46 ~ $ conda install -c bioconda samtools Collecting package metadata (current_repodata.json): done Solving environment: done ## Package Plan ## environment location: /home/wsx/miniconda3/envs/biosoft added / updated specs: - samtools The following packages will be downloaded: package | build ---------------------------|----------------- bzip2-1.0.8 | h7b6447c_0 78 KB defaults c-ares-1.18.1 | h7f8727e_0 114 KB defaults curl-7.80.0 | h7f8727e_0 95 KB defaults krb5-1.19.2 | hac12032_0 1.2 MB defaults libcurl-7.80.0 | h0b77cf5_0 339 KB defaults libedit-3.</description>
    </item>
    
    <item>
      <title>《生物学是什么》书摘</title>
      <link>/blog/whats-biology-notes/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/whats-biology-notes/</guid>
      <description>现代综合进化论。
分子进化的中性理论。
操纵子。
反转座子。
全基因模型（Omnigenic Model）。
生物大分子的化学修饰主要涉及三类蛋白质分子：
 书写器Writer：负责催化化学修饰。 擦除器Eraser：移除化学修饰。 阅读器Reader：识别携带修饰的分子。  生物体在响应内外环境变化和执行生命活动时通常采用2种调控模式：
 改变核酸和蛋白分子零件的数量和类型。 改变生物大分子的化学修饰状态。  </description>
    </item>
    
    <item>
      <title>4步为Jupyter Notebook添加Conda环境</title>
      <link>/blog/4-jupyter-notebook-conda/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/4-jupyter-notebook-conda/</guid>
      <description>第一步，创建conda环境 conda create --name firstEnv 你会看到类似下面的内容：
(base) PS C:\Users\Administrator&amp;gt; conda create --name firstEnv Collecting package metadata (current_repodata.json): done Solving environment: done ## Package Plan ## environment location: C:\miniconda\envs\firstEnv Proceed ([y]/n)? y Preparing transaction: done Verifying transaction: done Executing transaction: done # # To activate this environment, use # # $ conda activate firstEnv # # To deactivate an active environment, use # # $ conda deactivate 第二步，激活环境并安装你需要的软件包 conda activate firstEnv conda install -c conda-forge datar 这里以datar举例。</description>
    </item>
    
    <item>
      <title>R使用Jupyter Notebook那些事</title>
      <link>/blog/r-jupyter-notebook/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/r-jupyter-notebook/</guid>
      <description>在操作的一台服务器的R没有X11支持，Jupyter一运行代码就报错Kernel挂掉。而RStudio Server可以直接点击切换图形后端为Cairo。 Jupyter 怎么搞呢？
首先尝试了Stack Overflow的一个办法，在 ~/.Rprofile 中加入代码：
setHook(packageEvent(&amp;#34;grDevices&amp;#34;, &amp;#34;onLoad&amp;#34;), function(...) grDevices::X11.options(type = &amp;#34;cairo&amp;#34;)) options(device = &amp;#34;x11&amp;#34;) 最后还是在IRkernel的官方仓库问题区看到解决的办法：
 https://github.com/IRkernel/IRkernel/issues/388
 加入下面的语句就可以了。
## Set default &amp;#39;type&amp;#39; for png() calls - useful when X11 device is not available! ## NOTE: Needs &amp;#39;cairo&amp;#39; capability options(bitmapType=&amp;#39;cairo&amp;#39;) 完成后重启下Jupyter，然后等待一会，再试一试。
另外，由于Jupyter无法像R一样拖动绘图窗口实时修改图形大小，如果要改动的话需要 提前用下面的语句设置：
options(repr.plot.width = 4, repr.plot.height = 3) 我们可以写一个简化函数：
setplot = function(w=5, h=4, d = c(&amp;#34;svg&amp;#34;, &amp;#34;png&amp;#34;)) { options(repr.plot.width = w, repr.plot.height = h) options(jupyter.plot_mimetypes = paste0(&amp;#34;image/&amp;#34;, switch( match.</description>
    </item>
    
    <item>
      <title>R(Studio)中指定外部软件路径</title>
      <link>/blog/r-studio-specify-path/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/r-studio-specify-path/</guid>
      <description>在安装R kernel时报错：
&amp;gt; IRkernel::installspec() Error in IRkernel::installspec() : jupyter-client has to be installed but “jupyter kernelspec --version” exited with code 127. In addition: Warning message: In system2(&amp;#34;jupyter&amp;#34;, c(&amp;#34;kernelspec&amp;#34;, &amp;#34;--version&amp;#34;), FALSE, FALSE) : error in running command 这种情况是R识别不了外部的$PATH，我们可以通过~/.Rprofile进行修改配置。
在RStudio中运行file.edit(&amp;quot;~/.Rprofile&amp;quot;)或者手动打开，添加如下内容：
old_path = Sys.getenv(&amp;#34;PATH&amp;#34;) Sys.setenv(PATH = paste(old_path, &amp;#34;~/miniconda3/bin/&amp;#34;, sep = &amp;#34;:&amp;#34;)) 北外镜像近期使用经验整体还是比较稳定的，不妨添加：
options(BioC_mirror=&amp;#34;https://mirrors.bfsu.edu.cn/bioconductor&amp;#34;) options(&amp;#34;repos&amp;#34; = c(CRAN=&amp;#34;https://mirrors.bfsu.edu.cn/CRAN/&amp;#34;)) ~/.condarc中可以添加：
channels: - defaults show_channel_urls: true default_channels: - https://mirrors.bfsu.edu.cn/anaconda/pkgs/main - https://mirrors.bfsu.edu.cn/anaconda/pkgs/r - https://mirrors.bfsu.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.bfsu.edu.cn/anaconda/cloud msys2: https://mirrors.</description>
    </item>
    
    <item>
      <title>dials自定义grid示例</title>
      <link>/blog/dials-grid/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/dials-grid/</guid>
      <description>library(dials)library(dplyr)param_quant = function (label, range = c(10L, 1000L), type = &amp;quot;integer&amp;quot;, trans = NULL) {stopifnot(length(label) == 1L)names(label) = labelnew_quant_param(type = type, range = range, inclusive = c(TRUE, TRUE),trans = trans, label = label, finalize = NULL)}param_class = function (label, values) {stopifnot(length(label) == 1L)names(label) = labelnew_qual_param(type = &amp;quot;character&amp;quot;, values = values, label = label, finalize = NULL)}abc = grid_max_entropy(param_quant(&amp;quot;scale&amp;quot;),param_quant(&amp;quot;abc&amp;quot;, range = c(0, 1), trans = scales::log10_trans()),param_class(&amp;quot;gender&amp;quot;, c(&amp;quot;F&amp;quot;, &amp;quot;M&amp;quot;)),size = 100, original = FALSE)plot(abc$scale, abc$abc)</description>
    </item>
    
    <item>
      <title>通过tidymodels使用XGBOOST</title>
      <link>/blog/using-xgboost-with-tidymodels/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/using-xgboost-with-tidymodels/</guid>
      <description>原文：https://www.r-bloggers.com/2020/05/using-xgboost-with-tidymodels/
XGBoost是一个最初用C++编写的机器学习库，通过XGBoost R包中移植到R。在过去的几年里，XGBoost在Kaggle竞赛中的有效性让它大受欢迎。在Tychobra, XGBoost是我们的首选机器学习库。
在2016年和2017年，Kaggle被两种方法所主导:梯度升压机和深度学习。具体来说，梯度增强用于结构化数据可用的问题，而深度学习用于图像分类等感知问题。前者的实践者几乎总是使用优秀的XGBoost库。
Max Kuhn和Rstudio的其他人最近将他们的注意力从caret转向了 tidymodels （caret的继承者）。“tidymodels”是一个R包的集合，它们一起工作来简化和加强模型训练和优化。随着最近发布的tidymodels.org，我们觉得是时候给tidymodels R包一个机会了。
概览这篇文章中我们使用tidymodels包训练和优化XGBoost模型。我们使用的AmesHousing数据集，其中包含来自艾奥瓦州艾姆斯的住房数据。我们的模型将预测房屋销售价格。
加载包：
# datalibrary(AmesHousing)# data cleaninglibrary(janitor)# data preplibrary(dplyr)# tidymodelslibrary(rsample)library(recipes)library(parsnip)library(tune)library(dials)library(workflows)library(yardstick)# speed up computation with parrallel processing (optional)library(doParallel)all_cores &amp;lt;- parallel::detectCores(logical = FALSE)registerDoParallel(cores = all_cores)加载数据：
# set the random seed so we can reproduce any simulated results.set.seed(1234)# load the housing data and clean namesames_data &amp;lt;- make_ames() %&amp;gt;%janitor::clean_names()Step 0：探索性数据分析在这一点上，我们通常会对数据做一些简单的图表和总结，以获得对数据的高层次理解。为了简单起见，我们将从这篇文章中删除EDA过程，但是，在实际分析中，理解业务问题和执行有效的EDA通常是分析中最耗时和最关键的方面。</description>
    </item>
    
    <item>
      <title>Flux Overview：建立一个简单的预测</title>
      <link>/blog/flux-overview/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/flux-overview/</guid>
      <description>julia&amp;gt; using Flux julia&amp;gt; actual(x) = 4x + 2 actual (generic function with 1 method) 提供训练和测试集 julia&amp;gt; x_train, x_test = hcat(0:5...), hcat(6:10...) ([0 1 … 4 5], [6 7 … 9 10]) julia&amp;gt; y_train, y_test = actual.(x_train), actual.(x_test) ([2 6 … 18 22], [26 30 … 38 42]) 通常，你的训练和测试数据来自真实世界的观察，但这个函数将模拟真实世界的观察。
构建一个模型预测 julia&amp;gt; model = Dense(1, 1) Dense(1, 1) # 2 parameters julia&amp;gt; model.weight 1×1 Matrix{Float32}: -1.0924082 julia&amp;gt; model.bias 1-element Vector{Float32}: 0.0 在底层，一个全连接层是一个含有weight和bias的结构体。weight代表权重矩阵，bias代表偏置向量。 我们可以使用其他方式思考一个模型。在Flux中，模型是概念上的预测函数：</description>
    </item>
    
    <item>
      <title>如何用Julia语言创建软件包</title>
      <link>/blog/julia-packaging/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/julia-packaging/</guid>
      <description>源：https://jaantollander.com/post/how-to-create-software-packages-with-julia-language/
 介绍 本文将教你如何用Julia编程语言创建一个开源的软件包，并使用基于git的工作流开发软件包。例如，你将了解如何自动化单元测试和文档部署，以及发布包的新版本。此外，我们创建了Julia播放列表的逐步视频教程，以指导你通过这个过程。
安装Julia 首先，我们将从julialang网站的下载页面安装Julia编程语言。在Linux中，我们可以将存档解压缩到所需的位置。我们将使用~/software/目录。
~/.bashrc添加配置如下：
export PATH=&amp;#34;$PATH:$HOME/software/julia-1.5.3-linux-x86_64/julia-1.5.3/bin&amp;#34; 上面的版本根据你自己的实际情况进行修改。
Julia REPL  How to use Julia REPL for Developing Packages
 我们可以通过在命令行输入Julia来打开Julia REPL。Julia REPL有四种不同的模式：
 Julia模式julia&amp;gt;用于测试Julia代码。 包管理模式pkg&amp;gt;用于执行包管理命令。可以使用]进行激活。 帮助模式help?&amp;gt;用于打印帮助和文档。我们可以使用?进行激活。 Shell模式shell&amp;gt;用于执行shell命令。我们可以使用分号;进行激活。  我们可以使用回车符从其他模式退回到Julia模式。
包结构 我们的包结构将遵循使用Julia语言创建软件包的官方示例。我们可以在Example.jl中找到示例库。我们可以克隆示例库并对其进行研究。以点开头的目录可能被操作系统隐藏了。我们可以从文件系统设置中显示隐藏的文件。Julia包结构如下所示：
Example/ ├─ .git/ ├─ .github/ │ └─ workflows/ │ ├─ TagBot.yml │ └─ ci.yml ├─ docs/ │ ├─ src/ │ │ └─ index.md │ ├─ Project.toml │ └─ make.jl ├─ src/ │ └─ Example.jl ├─ test/ │ └─ runtests.</description>
    </item>
    
  </channel>
</rss>
