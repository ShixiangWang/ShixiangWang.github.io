<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on ShixiangWang
王诗翔</title>
    <link>/categories/blog/</link>
    <description>Recent content in Blog on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Slurm使用技巧</title>
      <link>/blog/slurm-tricks/</link>
      <pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/slurm-tricks/</guid>
      <description>Slurm的官方文档在：https://slurm.schedmd.com/。
这篇文章记录下我在工作中使用经常用到，但是一般的初级文档不会涉及的内容、操作。
系统节点资源概览 一般我们输入sinfo，只能看到非常精简的节点信息：
1$ sinfo 2PARTITION AVAIL TIMELIMIT NODES STATE NODELIST 3cn up infinite 1 mix cn03 4cn up infinite 2 alloc cn[01-02] 5cn up infinite 15 idle cn[04-18] 6fat up infinite 1 idle fat01 7gpu* up infinite 1 idle gpu01 我们可以添加几个选项来获得一个更为完备的信息：
1$ sinfo -Nel 2Fri Aug 6 15:54:17 2021 3NODELIST NODES PARTITION STATE CPUS S:C:T MEMORY TMP_DISK WEIGHT AVAIL_FE REASON 4cn01 1 cn allocated 80 80:1:1 771000 0 1 (null) none 5cn02 1 cn allocated 80 80:1:1 771000 0 1 (null) none 6cn03 1 cn mixed 80 80:1:1 771000 0 1 (null) none 7cn04 1 cn idle 80 80:1:1 771000 0 1 (null) none 8cn05 1 cn idle 80 80:1:1 771000 0 1 (null) none 9cn06 1 cn idle 80 80:1:1 771000 0 1 (null) none 10cn07 1 cn idle 80 80:1:1 771000 0 1 (null) none 11cn08 1 cn idle 80 80:1:1 771000 0 1 (null) none 12cn09 1 cn idle 80 80:1:1 771000 0 1 (null) none 13cn10 1 cn idle 80 80:1:1 771000 0 1 (null) none 14cn11 1 cn idle 80 80:1:1 771000 0 1 (null) none 15cn12 1 cn idle 80 80:1:1 771000 0 1 (null) none 16cn13 1 cn idle 80 80:1:1 771000 0 1 (null) none 17cn14 1 cn idle 80 80:1:1 771000 0 1 (null) none 18cn15 1 cn idle 80 80:1:1 771000 0 1 (null) none 19cn16 1 cn idle 80 80:1:1 771000 0 1 (null) none 20cn17 1 cn idle 80 80:1:1 771000 0 1 (null) none 21cn18 1 cn idle 80 80:1:1 771000 0 1 (null) none 22fat01 1 fat idle 80 80:1:1 296649 0 1 (null) none 23gpu01 1 gpu* idle 40 40:1:1 772000 0 1 (null) none 全部的选项介绍在文档sinfo中。</description>
    </item>
    
    <item>
      <title>LeetCode：0001-两数之和</title>
      <link>/blog/leetcode-0001-two-sum/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/leetcode-0001-two-sum/</guid>
      <description>难度：简单。
参考：
  https://leetcode-cn.com/problems/two-sum
  https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0001.Two-Sum/
  代码仓库：https://github.com/ShixiangWang/LeetCode
问题 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出 和为目标值target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
示例：
1输入：nums = [2,7,11,15], target = 9 2输出：[0,1] 3解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 题解 顺序扫描数组，对每一个元素，在map中找能组合给定值的另一半数字，如果找到了，直接返回2个数字的下标即可。如果找不到，就把这个数字存入map中，等待扫到“另一半”数字的时候，再取出来返回结果。
这种解法将数据扫描一遍必然得到结果，所以时间复杂度是O(n)。
Go 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func twoSum(nums []int, target int) []int { 6 m := make(map[int]int) 7 for i := 0; i &amp;lt; len(nums); i++ { 8 another := target - nums[i] 9 if _, ok := m[another]; ok { 10 return []int{m[another], i} 11 } 12 m[nums[i]] = i 13 } 14 return nil 15} 16 17func main() { 18 fmt.</description>
    </item>
    
    <item>
      <title>旧文存档</title>
      <link>/blog/blog-archives/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/blog-archives/</guid>
      <description> GitHub Home 博客：https://shixiangwang.github.io/home 语雀：https://www.yuque.com/shixiangwang 我来：https://www.wolai.com/sCHoE8HyUFnDEuCrth7PZG  </description>
    </item>
    
    <item>
      <title>RMarkdown template from my reference blog</title>
      <link>/blog/questions-answers-and-reprexes/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/questions-answers-and-reprexes/</guid>
      <description>I stumbled into a niche YouTube genre:Web Development online instructors (a.k.a content creators)challenge each other to “CSS Battles”.
Turns out they are fascinating videoswhere experienced programmers talk and fumbletheir way through their coding.
As they talked through their thought processes,I thought about the questions we askwhen our code goes wrongand the answers we get when we reprex.
CSS Battle with The CSS King  I challenged The CSS King to a CSS Battle on YouTubeI’ve thought a lot about this video since I watched it.</description>
    </item>
    
  </channel>
</rss>
