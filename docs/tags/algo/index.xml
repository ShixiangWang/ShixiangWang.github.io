<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algo on ShixiangWang
王诗翔</title>
    <link>/tags/algo/</link>
    <description>Recent content in algo on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>R小技巧：分组应用和排序去重的应用与比较</title>
      <link>/blog/r-tricks-remove-duplicates-after-ordering/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/r-tricks-remove-duplicates-after-ordering/</guid>
      <description>问题与方案 假设我们有这样一个数据集：
df &amp;lt;- data.frame( c1 = c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), c2 = c(1, 3, 2, 1, 4, 2) ) df out c1 c2 out 1 a 1 out 2 a 3 out 3 a 2 out 4 b 1 out 5 b 4 out 6 c 2 如果我们想保留每个c1分类和分类下的最大值，你会怎么操作？
思考一分钟。
如果使用惯了tidyverse套装，我们脑子里容易冒出来的是这样的解法：使用分组应用。
library(dplyr) df |&amp;gt; group_by(c1) |&amp;gt; summarize(c2 = max(c2, na.rm = TRUE)) out # A tibble: 3 × 2 out c1 c2 out &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; out 1 a 3 out 2 b 4 out 3 c 2 在数据不是特别大的时候，使用这种策略没有任何问题。但如果分组有成千上万，分组的时间代价就很高了。有没有其他的方式可以解决该问题呢？</description>
    </item>
    
    <item>
      <title>LeetCode：0001-两数之和</title>
      <link>/blog/leetcode-0001-two-sum/</link>
      <pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/leetcode-0001-two-sum/</guid>
      <description>难度：简单。
参考：
  https://leetcode-cn.com/problems/two-sum
  https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0001.Two-Sum/
  代码仓库：https://github.com/ShixiangWang/LeetCode
问题 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出 和为目标值target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
示例：
1输入：nums = [2,7,11,15], target = 9 2输出：[0,1] 3解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 题解 顺序扫描数组，对每一个元素，在map中找能组合给定值的另一半数字，如果找到了，直接返回2个数字的下标即可。如果找不到，就把这个数字存入map中，等待扫到“另一半”数字的时候，再取出来返回结果。
这种解法将数据扫描一遍必然得到结果，所以时间复杂度是O(n)。
Go 1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func twoSum(nums []int, target int) []int { 6 m := make(map[int]int) 7 for i := 0; i &amp;lt; len(nums); i++ { 8 another := target - nums[i] 9 if _, ok := m[another]; ok { 10 return []int{m[another], i} 11 } 12 m[nums[i]] = i 13 } 14 return nil 15} 16 17func main() { 18 fmt.</description>
    </item>
    
  </channel>
</rss>
