<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rcpp on ShixiangWang
王诗翔</title>
    <link>/tags/rcpp/</link>
    <description>Recent content in Rcpp on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/rcpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rcpp：什么时候使用Rcpp</title>
      <link>/blog/when-use-rcpp/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/when-use-rcpp/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/010_Rcpp_merit.html
什么时候使用  后面的迭代依赖于前面的迭代的循环操作。 需要访问向量/矩阵的每个元素。 在循环中循环调用函数。 动态更改向量的大小。 需要高级数据结构和算法的操作。  怎么配置 除了Windows需要安装Rtools，其他系统中一般已经装好了。
如果我们要自定义C++的配置，如更改编译器，需要使用到配置文件.R/Makevars。
下面是一个示例：
CC=/opt/local/bin/gcc-mp-4.7 CXX=/opt/local/bin/g++-mp-4.7 CPLUS_INCLUDE_PATH=/opt/local/include:$CPLUS_INCLUDE_PATH LD_LIBRARY_PATH=/opt/local/lib:$LD_LIBRARY_PATH CXXFLAGS= -g0 -O2 -Wall MAKE=make -j4  包括编译器位置、头文件位置、动态库位置、编译参数等。
 安装Rcpp install.packages(&amp;#34;Rcpp&amp;#34;) </description>
    </item>
    
    <item>
      <title>Rcpp：基本用法</title>
      <link>/blog/rcpp-basic-usage/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-basic-usage/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/030_basic_usage.html
使用Rcpp函数只需要3步：
 编写Rcpp源代码。 编译代码。 执行函数。  编写Rcpp代码 下面是一个对向量求和的Rcpp函数：
//sum.cpp #include &amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&amp;lt;v.length(); ++i){ sum += v[i]; } return(sum); } Rcpp函数定义格式 下面是定义一个Rcpp函数的基本格式：
#include&amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){ //do something  return RETURN_VALUE; }  #include&amp;lt;Rcpp.h&amp;gt;：这个句子允许你使用Rcpp包定义的类和函数。 // [[Rcpp::export]]：这个句子下面定义的函数可以从R中访问。 你需要把这个句子附加到你想从R中使用的每个函数中。 using namespace Rcpp;：这个句子是可选的。但是如果你没有写这个句子， 你必须添加前缀Rcpp::来指定由Rcpp定义的类和函数。(例如：Rcpp::NumericVector) RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}：你需要指定函数和参数的数据类型。 return RETURN_VALUE;：如果函数将返回一个值，return语句是强制性的。 然而，如果你的函数没有返回值（即RETURN_TYPE是无效的），返回语句可以省略。  编译代码 函数Rcpp::sourceCpp()将编译你的源代码，并将定义的函数加载到R。
library(Rcpp) sourceCpp(&amp;#39;sum.cpp&amp;#39;) 使用函数 像正常R函数一样调用它就可以了。</description>
    </item>
    
    <item>
      <title>Rcpp：数据结构</title>
      <link>/blog/rcpp-data-structure/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-data-structure/</guid>
      <description>RObject类 RObject类在Rcpp类系统中占核心地位。虽然它不是面向用户的，但为接下来的所有类提供了公共的数据结构，它是构建Rcpp API的基础类。
每一个RObject类实例都封装了一个R对象，而每个对象在内部可以表示为一个SEXP：一个指向S表达式对象的指针。
基于它的用户可见（可使用）的类：
  IntegerVector对应整型向量。
  NumericVector对应数值向量。
  LogicalVector对应逻辑值向量。
  CharacterVector对应Character向量。
  GenericVector对应List类型的泛型向量。
  ExpressionVector对应表达式类型向量。
  RawVector对应raw类型向量。
  对于整型和数值型，我们还有IntegerMatrix和NumericMatrix对应R中的数值矩阵。
下面我们通过整型向量来了解它们。
IntegerVector类 模板函数as&amp;lt;&amp;gt;()用于从R转换到C++，而wrap()函数的方向相反。
 实际大多数使用情况下，我们已经不需要显式地进行转换处理，该过程会在底层自动完成。
 示例：返回完美数 什么是完美数：
https://baike.baidu.com/item/完全数/370913?fromtitle=完美数&amp;amp;fromid=871560&amp;amp;fr=aladdin
代码：
library(Rcpp) library(inline) src &amp;lt;- &amp;#39; Rcpp::IntegerVector epn(4); epn[0] = 6; epn[1] = 14; epn[2] = 496; epn[3] = 8182; return epn; &amp;#39; func &amp;lt;- cxxfunction(signature(), src, plugin = &amp;#34;Rcpp&amp;#34;) 调用：
&amp;gt; func() [1] 6 14 496 8182 示例：使用输入 求乘积。</description>
    </item>
    
  </channel>
</rss>
