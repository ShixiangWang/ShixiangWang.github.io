<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习 on ShixiangWang
(王诗翔)</title>
    <link>/tags/%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 学习 on ShixiangWang
(王诗翔)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ggplot构建新图形元素</title>
      <link>/blog/ggplot-build-new-object/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot-build-new-object/</guid>
      <description>2021/05/24 19:35
 原文：https://bookdown.org/rdpeng/RProgDA/building-new-graphical-elements.html
 由ggplot构造的数据图中的关键元素包括geoms（几何对象）和stats（统计变换）。事实上，ggplot2包具有强大的功能，允许用户制作各种有趣而丰富的数据图形。这些图形可以通过组合调用各种geom_*和stat_*函数(以及其他类函数)来实现。
为什么要构造新的图形元素？
  实现ggplot2目前不存在的特性。
  简化复杂的工作流。如果你总是发现自己在用重复的代码绘制类似的图形元素。
  创建新的geoms和stats可以简化代码，让用户轻松调整情节的某些元素，而不必每次都费劲地处理整个代码。
构造一个geom ggplot2中的新geoms继承自一个名为Geom的顶级类，并使用两步流程构造：
  ggproto()函数用于构造一个与新的geom对应的新类。这个新类指定了许多属性和函数，这些属性和函数描述了如何在图上绘制数据。
  geom_*函数被构造为标准函数。这个函数返回一个层，该层可以添加到使用ggplot()函数创建的plot中。
  新的geom类的基本设置如下所示：
GeomNEW &amp;lt;- ggproto(&amp;#34;GeomNEW&amp;#34;, Geom, required_aes = &amp;lt;a character vector of required aesthetics&amp;gt;, default_aes = aes(&amp;lt;default values for certain aesthetics&amp;gt;), draw_key = &amp;lt;a function used to draw the key in the legend&amp;gt;, draw_panel = function(data, panel_scales, coord) { ## 返回一个grid grob对象的函数 ## 是绘图真正工作的地方 } ) 所需的美学映射应该很简单——例如，如果你的新geom生成了一种特殊的散点图，那么你可能需要x和y映射。美学映射的默认值可以包括绘图符号如形状、颜色等内容。</description>
    </item>
    
    <item>
      <title>grid 1：图形对象grobs</title>
      <link>/blog/grobs/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grobs/</guid>
      <description>学习材料：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#grobs
grobs 是 grid 绘图系统中图形对象的表示，即 graphics + objects = grobs
grobs 的创建通常使用以 Grob 作为后缀的函数们，包括circleGrob, linesGrob, polygonGrob, rasterGrob, rectGrob, segmentsGrob, legendGrob, xaxisGrob, and yaxisGrob 等等。 gridExtra 包定义了更多的图形对象。
下面是一个绘圆的示例：
library(grid) my_circle &amp;lt;- circleGrob(x = 0.5, y = 0.5, r = 0.5, gp = gpar(col = &amp;#34;gray&amp;#34;, lty = 3)) 每个图形对象有自带的参数，比如圆有它的中心，半径。而不同的对象有相同的一些参数设定，包括颜色、线型、大小等等，这通过 gpar 函数进行设定。
再创建图形对象后，使用 grid.draw() 将图形绘制出来。
grid.draw(my_circle) 多个图形对象可以叠加，而且叠加后可以修改原来的图形对象。
my_circle &amp;lt;- circleGrob(name = &amp;#34;my_circle&amp;#34;, x = 0.5, y = 0.5, r = 0.5, gp = gpar(col = &amp;#34;gray&amp;#34;, lty = 3)) grid.</description>
    </item>
    
    <item>
      <title>grid 2：视图 viewports</title>
      <link>/blog/viewports/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/viewports/</guid>
      <description>原文：https://bookdown.org/rdpeng/RProgDA/the-grid-package.html#viewports
 视图是什么 视图是绘图窗口，我们可以将其移进或移出，以方便使用grid包定制绘图。我们可以导航到其中一个视图，进行一些更改，然后弹出并导航到另一个视图。简而言之，视图提供了一种在绘图（可以想象为一个画板）的不同子空间（不同的层，如果了解ggplot2，采用图层概念理解它）中导航和工作的方法。
下面是一个例子，我们在整个图形的右上角绘制一个棒棒图：
# 默认，grid会初始化第一个视图 grid.draw(rectGrob()) # 创建一个小的视图 # 指定新视图的位置，X为0.5，Y为0.5，视图高宽都为0.5 sample_vp &amp;lt;- viewport(x = 0.5, y = 0.5, width = 0.5, height = 0.5, just = c(&amp;#34;left&amp;#34;, &amp;#34;bottom&amp;#34;)) # 位置校正参数 # 导航视图：上面只是定义了一个视图对象 # 我们可以想象为一个大画板是一张白纸 # 我们上面准备了一张小的白纸 # 而 push 的目的就是把小的白纸放到大白纸的对应位置 # 接下来的绘图动作就是在小的白纸上进行的 pushViewport(sample_vp) grid.draw(roundrectGrob()) grid.draw(lollipop) # 弹出最上层的视图 popViewport()  棒棒图的绘制见「R」grid 图形对象 grobs一文末尾。
 视图的just参数 值得注意的是这里的just参数：它定义了新的视图是如何在旧（大） 的视图上摆放的。这里的c(&amp;quot;left&amp;quot;, &amp;quot;bottom&amp;quot;)指定了小的视图的左侧和下侧与其坐标单位0.5, 0.5对齐。我们看看修改下该参数的效果：
grid.draw(rectGrob()) sample_vp &amp;lt;- viewport(x = 0.5, y = 0.5, width = 0.</description>
    </item>
    
    <item>
      <title>grid 3：图形坐标系统</title>
      <link>/blog/coords/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/coords/</guid>
      <description>绘图时，我们需要坐标才能准确地对要绘制的对象进行定位。在 grid 包中，有多种绘图坐标系统，选择一个合适的加以利用可以帮助我们更好地绘制图形。
坐标系统不同的单位：
  native 单位：根据数据值。
  n pc单位：将整个（笛卡尔）坐标系缩放为0到1范围。
  实际尺寸单位：包括英寸、厘米、毫米。
  例如，下面的绘图同时用到了前两者：
ex_vp &amp;lt;- viewport(x = 0.5, y = 0.5, # npc 单位 just = c(&amp;#34;center&amp;#34;, &amp;#34;center&amp;#34;), height = 0.8, width = 0.8, xscale = c(0, 100), yscale = c(0, 10)) # 设定native单位 pushViewport(ex_vp) grid.draw(rectGrob()) grid.draw(circleGrob(x = unit(20, &amp;#34;native&amp;#34;), y = unit(5, &amp;#34;native&amp;#34;), # 根据native单位绘图 r = 0.1, gp = gpar(fill = &amp;#34;lightblue&amp;#34;))) grid.draw(circleGrob(x = unit(85, &amp;#34;native&amp;#34;), y = unit(8, &amp;#34;native&amp;#34;), r = 0.</description>
    </item>
    
    <item>
      <title>grid 4：gridExtra包</title>
      <link>/blog/grid-4-gridextra%E5%8C%85/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/grid-4-gridextra%E5%8C%85/</guid>
      <description>gridExtra包提供了grid系统的有用拓展，包括对grobs对象的操作方法和其他一些grobs对象。
grid.arrange()可以绘制多个对象：
library(gridExtra) grid.arrange(lollipop, circleGrob(), rectGrob(), lollipop, ncol = 2) 由于ggplot2也是基于grid系统的，所以我们可以使用该函数对ggplot对象组合排序：
time_vs_shots &amp;lt;- ggplot(worldcup, aes(x = Time, y = Shots)) + geom_point() player_positions &amp;lt;- ggplot(worldcup, aes(x = Position)) + geom_bar() grid.arrange(time_vs_shots, player_positions, ncol = 2) 使用layout_matrix选项可以进行更自定义控制：
grid.arrange(time_vs_shots, player_positions, layout_matrix = matrix(c(1, 2, 2), ncol = 3)) 包括图形填充：
grid.arrange(time_vs_shots, player_positions, layout_matrix = matrix(c(1, NA, NA, NA, 2, 2), byrow = TRUE, ncol = 3)) 使用tableGrob()函数，我们可以在图中嵌入表格。下面是一个略微复杂的例子：
worldcup_table &amp;lt;- worldcup %&amp;gt;% filter(Team %in% c(&amp;#34;Germany&amp;#34;, &amp;#34;Spain&amp;#34;, &amp;#34;Netherlands&amp;#34;, &amp;#34;Uruguay&amp;#34;)) %&amp;gt;% group_by(Team) %&amp;gt;% dplyr::summarize(`Average time` = round(mean(Time), 1), `Average shots` = round(mean(Shots), 1)) %&amp;gt;% tableGrob() `summarise()` ungrouping output (override with `.</description>
    </item>
    
    <item>
      <title>Rcpp：数据结构</title>
      <link>/blog/rcpp-data-structure/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-data-structure/</guid>
      <description>RObject类 RObject类在Rcpp类系统中占核心地位。虽然它不是面向用户的，但为接下来的所有类提供了公共的数据结构，它是构建Rcpp API的基础类。
每一个RObject类实例都封装了一个R对象，而每个对象在内部可以表示为一个SEXP：一个指向S表达式对象的指针。
基于它的用户可见（可使用）的类：
  IntegerVector对应整型向量。
  NumericVector对应数值向量。
  LogicalVector对应逻辑值向量。
  CharacterVector对应Character向量。
  GenericVector对应List类型的泛型向量。
  ExpressionVector对应表达式类型向量。
  RawVector对应raw类型向量。
  对于整型和数值型，我们还有IntegerMatrix和NumericMatrix对应R中的数值矩阵。
下面我们通过整型向量来了解它们。
IntegerVector类 模板函数as&amp;lt;&amp;gt;()用于从R转换到C++，而wrap()函数的方向相反。
 实际大多数使用情况下，我们已经不需要显式地进行转换处理，该过程会在底层自动完成。
 示例：返回完美数 什么是完美数：
https://baike.baidu.com/item/完全数/370913?fromtitle=完美数&amp;amp;fromid=871560&amp;amp;fr=aladdin
代码：
library(Rcpp) library(inline) src &amp;lt;- &amp;#39; Rcpp::IntegerVector epn(4); epn[0] = 6; epn[1] = 14; epn[2] = 496; epn[3] = 8182; return epn; &amp;#39; func &amp;lt;- cxxfunction(signature(), src, plugin = &amp;#34;Rcpp&amp;#34;) 调用：
&amp;gt; func() [1] 6 14 496 8182 示例：使用输入 求乘积。</description>
    </item>
    
    <item>
      <title>Unix：Bash编程</title>
      <link>/blog/unix-bash-programming/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-bash-programming/</guid>
      <description>原文：https://seankross.com/the-unix-workbench/bash-programming.html
 数学 创建math.sh：
#!/usr/bin/env bash # File: math.sh expr 5 + 2 expr 5 - 2 expr 5 \* 2 # 转义 expr 5 / 2 保存然后运行：
$ bash math.sh 7 3 10 2 ⚠️注意，bash使用整除法。求余使用%符号。
如果我们想要进行更为复杂的数学计算，使用bc命令。
创建文件bigmath.sh：
#!/usr/bin/env bash # File: bigmath.sh echo &amp;#34;22 / 7&amp;#34; | bc -l echo &amp;#34;4.2 * 9.15&amp;#34; | bc -l echo &amp;#34;(6.5 / 0.5) + (6 * 2.2)&amp;#34; | bc -l 结果：</description>
    </item>
    
    <item>
      <title>Unix：Make</title>
      <link>/blog/unix-make/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-make/</guid>
      <description>2021/05/26 22:01
 原文：https://seankross.com/the-unix-workbench/working-with-unix.html#make
 从前没有网页浏览器、文件浏览器、开始菜单或搜索栏。当有人启动电脑时，他们得到的是一个shell提示符，他们做的所有工作都是从这个提示符开始的。那时候，人们仍然喜欢共享软件，但总是存在软件应该如何安装的问题。make程序是解决这个问题的最好的尝试，make的优雅使它至今仍被广泛使用。make的指导设计目标是为了安装一些新软件:
  将所有的依赖下载到一个目录。
  cd进入目录。
  运行make。
  这是通过指定一个名为makefile的文件来实现的，该文件描述了不同文件和程序之间的关系 。除了安装程序之外，make对于自动创建文档也很有用。让我们构建一个makefile，它创建一个readme.txt文件，该文件自动填充有关当前目录的一些信息。
首先进入目录并创建一个文件：
▶ cd ~/Documents/test ▶ nano makefile 填入如下内容：
draft_journal_entry.txt: touch draft_journal_entry.txt 上面简单的makefile说明了一个规则，它的一般格式如下：
[target]: [dependencies...] [commands...] 在这个简单的示例中，我们创建了以draft_journal_entry.txt为目标的文件，该文件是作为命令的结果创建的。需要注意的是，目标下的任何命令都必须用Tab缩进。如果我们不使用Tab 来缩进命令，那么make将失败。让我们保存并关闭makefile，然后我们可以在控制台中运行以下命令：
▶ ls makefile 然后使用下面的操作查看make使用方式：
▶ make draft_journal_entry.txt touch draft_journal_entry.txt ▶ ls draft_journal_entry.txt makefile 在我们为draft_journal_entry.txt目标定义的规则下缩进的命令已经执行，所以现在draft_journal_entry.txt存在！让我们再次运行相同的make命令：
▶ make draft_journal_entry.txt make: `draft_journal_entry.txt&amp;#39; is up to date. 因为目标文件已经存在，所以没有采取任何操作，相反，我们被告知，draft_journal_entry.txt的规则是“最新的”(没有什么需要做的)。
如果我们看一下我们之前草拟的一般规则格式，我们可以看到我们没有为该规则指定任何依赖项。依赖项是目标在构建时所依赖的文件。如果自上次为目标运行make以来，依赖项已经更新，则目标不是“最新的”。这意味着下次为该目标运行make时将运行该目标的命令。通过这种方式，对依赖项的更改被合并到目标中。为了避免不必要地运行命令，这些命令只在依赖项改变时运行，或者当目标根本不存在时运行。
让我们更新makefile，以包含自动生成的readme.txt。首先，让我们添加文件：
▶ echo &amp;#34;1. 2017-06-15-In-Boston&amp;#34; &amp;gt; toc.txt makefile修改为：
draft_journal_entry.txt: touch draft_journal_entry.</description>
    </item>
    
    <item>
      <title>使用Circle-Map Realign鉴定环形DNA</title>
      <link>/blog/use-circle-map-for-detecting-eccdna/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-circle-map-for-detecting-eccdna/</guid>
      <description>2021/07/23 19:39
 原文：https://github.com/iprada/Circle-Map/wiki/Tutorial:-Identification-of-circular-DNA-using-Circle-Map-Realign
 这是一个教程，一步一步地解释如何从原始数据(fastq文件)到一个可解释的，标签分离的bed文件指示染色体坐标的DNA环。为了制作教程，我们模拟了Illumina读取来自人类基因组未知区域的环形DNA。本教程的目的是使用Circle-Map来提取环形DNA的来源。
依赖   GNU/Linux
  BWA
  samtools
  Circle-Map
  conda install -c bioconda bwa samtools pip3 install Circle-Map pip3 install biopython==1.77 # 不安装这个版本目前使用会报错 第一步：准备和下载数据 下载原始数据 直接克隆仓库：
git clone https://github.com/iprada/Circle-Map 下载和准备参考基因组 wget http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz gunzip -d hg38.fa.gz bwa index hg38.fa samtools faidx hg38.fa 第二步：比对到参考基因组 cd Circle-Map/tutorial/ bwa mem -q ~/data/refs/hg38.fa unknown_circle_reads_1.fastq unknown_circle_reads_2.fastq &amp;gt; unknown_circle.sam 这就产生了一个SAM文件，其中包含了关于reads在哪里以及如何与基因组对齐的信息。
  我们使用 -q 选项（query name sorted）为BWA中的拆分读对比对分配独立的映射质量分数 。这可以改进Circle-Map概率模型中断点图权值的估计。</description>
    </item>
    
  </channel>
</rss>
