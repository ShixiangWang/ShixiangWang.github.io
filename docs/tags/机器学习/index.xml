<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>机器学习 on ShixiangWang
王诗翔</title>
    <link>/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</link>
    <description>Recent content in 机器学习 on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mlr3（二）基础</title>
      <link>/blog/mlr3-basics/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-basics/</guid>
      <description>来源：https://mlr3book.mlr-org.com/basics.html
本文将教你基本的mlr3知识，以及它的R6类和操作以用于机器学习。典型的机器学习工作流是这样的:
 Figure 1: 机器学习流程 source: https://mlr3book.mlr-org.com/images/ml_abstraction.svg  mlr3将数据封装在任务中，并将其分解为互不重叠的训练集和测试集。由于我们感兴趣的模型外推到新的数据，而不仅仅是记忆训练数据，独立的测试数据允许客观地评估模型的泛化。训练数据被提供给一个机器学习算法，在mlr3中我们称之为learner。learner利用训练数据建立输入特征与输出目标值之间关系的模型。然后使用该模型对测试数据进行预测，并将其与参考真值进行比较，以评估模型的质量。mlr3提供了许多不同的度量方法，根据预测值和实际值之间的差异来量化模型的执行情况。通常这是一个数字分数。
将数据分割为训练集和测试集、建立模型并对其进行评估的过程可能会重复多次，每次从原始数据中重新采样不同的训练集和测试集。多重重采样迭代允许我们对特定类型的模型获得更好、更一般化的性能估计，因为它是在不同的条件下测试的，而且由于数据重采样的特定方式，它不太容易产生偏差。
在许多情况下，这个简单的工作流不足以处理真实世界的数据，可能需要规范化（标准化）、缺失值的输入或特征选择。我们将在以后介绍更复杂的工作流程。
本文涵盖以下小主题：
任务：
任务用元信息封装数据，比如预测目标列的名称。我们将介绍如何：
 访问预定义的任务 指定一个任务类型 创建一个任务 使用任务的API工作 为任务的行和列分配角色 实施任务mutator 获取存储在任务中的数据  学习器
学习器封装机器学习算法来训练模型并对任务进行预测。它们由R和其他包提供。我们将介绍如何：
 访问随mlr3而来的分类和回归学习器集合，并检索特定的学习器 访问学习器的超参数值集并修改它们  如何修改和扩展学习器涵盖在补充高级技术部分。
训练和预测
关于训练和预测方法的部分说明了如何使用任务和学习器训练模型并对新数据集进行预测。特别地，我们将介绍如何：
 正确设置任务和学习器 为一项任务设置训练和测试分割（集） 在训练集上训练学习器以生成模型 生成测试集的预测 通过比较预测值和实际值来评估模型的性能  重采样
重采样是一种创建训练和测试分割（集）的方法。我们将介绍：
 访问和选择重采样策略 通过应用重采样实例化分割到训练集和测试集 执行重采样以获得结果  关于重采样的附加信息可以在嵌套重采样部分和模型优化一章中找到。
基准测试
基准测试用于比较不同模型的性能，例如不同学习器训练的模型，不同任务训练的模型，或不同重采样方法训练的模型。我们介绍如何
 创建一个基准设计 执行设计并汇总结果 将基准测试对象转换为重采样对象  二分类
二值分类是分类的一种特殊情况，预测的目标变量只有两个可能的值。在这种情况下，还需要考虑其他因素。特别是：
 ROC曲线和预测一个类和另一个类的阈值 阈值调整  在详细介绍如何使用mlr3进行机器学习之前，我们先简要介绍一下R6，因为它是R相对较新的一部分。mlr3严重依赖于R6，它提供的所有基本构造都是R6类：
 任务 task 学习器 learner 测量 measure 重采样 resamplings  快速R6入门介绍 R6是R最新的面向对象编程(OO)方言之一。它解决了R中早期OO实现的缺点，比如我们在mlr中使用的S3。如果你以前做过面向对象编程，那么R6应该很熟悉。我们关注的是R6的部分，你需要知道在这里使用mlr3。</description>
    </item>
    
    <item>
      <title>mlr3（一）快速入门</title>
      <link>/blog/mlr3-quickstart/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-quickstart/</guid>
      <description>来源：https://mlr3book.mlr-org.com/quickstart.html
安装包：
install.packages(&amp;quot;mlr3&amp;quot;) 作为一个30秒的介绍性示例，我们将在虹膜数据集的前120行训练决策树模型，并对最后30行进行预测，测量训练模型的准确性。
library(&amp;quot;mlr3&amp;quot;) task = tsk(&amp;quot;iris&amp;quot;) learner = lrn(&amp;quot;classif.rpart&amp;quot;) # 为任务的一个子集（前120行）训练这个学习者的模型 learner$train(task, row_ids = 1:120) # 决策树模型 learner$model out n= 120 out out node), split, n, loss, yval, (yprob) out * denotes terminal node out out 1) root 120 70 setosa (0.41666667 0.41666667 0.16666667) out 2) Petal.Length&amp;lt; 2.45 50 0 setosa (1.00000000 0.00000000 0.00000000) * out 3) Petal.Length&amp;gt;=2.45 70 20 versicolor (0.00000000 0.71428571 0.28571429) out 6) Petal.</description>
    </item>
    
    <item>
      <title>PR曲线与AUC</title>
      <link>/blog/pr-curve-and-auc-value/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/pr-curve-and-auc-value/</guid>
      <description>这里直接使用ROCR包提供的数据作为示例：
library(ROCR) data(ROCR.simple) pred &amp;lt;- prediction(ROCR.simple$predictions, ROCR.simple$labels) perf &amp;lt;- performance(pred,&amp;quot;tpr&amp;quot;,&amp;quot;fpr&amp;quot;) plot(perf) ## precision/recall curve (x-axis: recall, y-axis: precision) perf1 &amp;lt;- performance(pred, &amp;quot;prec&amp;quot;, &amp;quot;rec&amp;quot;) plot(perf1, xlim = c(0, 1), ylim = c(0, 1)) 使用 PRROC 包获取PR AUC值并且绘图：
pr &amp;lt;- PRROC::pr.curve(ROCR.simple$predictions, weights.class0 = ROCR.simple$labels, curve = TRUE) pr ## ## Precision-recall curve ## ## Area under curve (Integral): ## 0.7815038 ## ## Area under curve (Davis &amp;amp; Goadrich): ## 0.7814246 ## ## Curve for scores from 0.</description>
    </item>
    
    <item>
      <title>《R语言数据科学导论》笔记</title>
      <link>/blog/note-for-r-data-science-intro/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/note-for-r-data-science-intro/</guid>
      <description>原始资料来源：https://github.com/leovan/data-science-introduction-with-r
特征工程 特征工程是将原始数据转换成特征的过程。更通俗地说，特征工程就是人工设计模型的输入变量 x的过程。
主要分为：
 数据预处理 特征提取和选择 特征变换和编码 特征监控  数据预处理 对赃数据进行清洗，包括括缺失，噪声，不一致等等一系列问题数据。
剔除处理：
 样本去重。同一个ID出现多次重复记录。 特征去重。例如月收入和年收入，它们都是用于表征收入特征，关系只差常数倍。 常量特征剔除。即常量或方差近似为0的特征。caret包中的nearZeroVar()可以帮助我们识别该类特征。  缺失值处理：
 探索缺失值：mice包的md.pattern()，VIM包的aggr()/marginplot()。 处理：  删除法，可以直接使用na.omit()。 插补法，如果该特征对最终的预测结果影响较小，则我们可以直接删除该特征；相反如果该特征对预测结果影响较大，直接删除会对模型造成较大的影 响，此时我们需要利用其它的方法对该特征的缺失值进行填补。其中最简单的方式是利用均值，中位数或众数等统计量对其进行简单插补。这种插补方法是建立在完全随机缺失的前提假设下，同时会造成变量方差变小。    异常值是指样本中存在的同样本整体差异较大的数据。
分为2类：
采样是一种常见的预处理技术。
 随机采样。每个样本单位被抽中的概率相等，样本的每个单位完全独立，彼此间无一定的关联性和排斥性。 分层采样。将抽样单位按某种特征或某种规则划分为不同的层，然后从不同的层中独立、随机地抽取样本。从而保证样本的结构与总体的结构比较相近，从而提高估计的精度。可以利用sampling::strata()。 欠采样和过采样。我们经常会碰到不同分类的样本比例相差较大的问题，这种问题会对我们构建模型造成很大的影响，因此从数据角度出发，我们可以利用欠采样或过采样处理这种现象。可以利用ROSE::ovun.sample()。  特征变换和编码 无量纲化 通过归一化，我们可以消除不同量纲下的数据对最终结果的影响。
1normalize &amp;lt;- function(x) { 2 # 计算极值 3 x_min &amp;lt;- min(x) 4 x_max &amp;lt;- max(x) 5 # 归一化 6 x_n &amp;lt;- (x - x_min) / 7 (x_max - x_min) 8 # 将极值作为结果的属性 9 attr(x_n, 10 &amp;#39;min&amp;#39;) &amp;lt;- x_min 11 attr(x_n, 12 &amp;#39;max&amp;#39;) &amp;lt;- x_max 13 # 返回归一化后结果 14 x_n 15} 标准化。</description>
    </item>
    
  </channel>
</rss>
