<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unix on ShixiangWang
(王诗翔)</title>
    <link>/tags/unix/</link>
    <description>Recent content in Unix on ShixiangWang
(王诗翔)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/unix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CentOS/Redhat R包使用最新的gcc编译</title>
      <link>/blog/use-new-gcc-on-centos-for-r/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-new-gcc-on-centos-for-r/</guid>
      <description>R包在Linux下编译不通过，原因是gcc版本太低怎么办？
一些有C++代码的R包可能会用到一些新的C++特性，需要C++11或者C++14。这个问题通常在CentOS/红帽系统上出现，因为系统稳定的要求，这个系列的系统它的C++版本很低。 但请读者前往注意了别自己编译新版本的gcc，然后替换掉系统的。这种操作我试过几次，系统基本上就崩掉了。
正确的解决方式是安装独立的gcc，通过环境变量引用和使用它。
在Root用户下操作：
yum install centos-release-scl yum install devtoolset-9 然后在你使用R的用户下操作：
# If you use your non-root account to install packages,  # change /root to /home/your_id in the following command mkdir -p /root/.R vi /root/.R/Makevars 将下面的内容写入打开的文件，然后保存：
CXX11=/opt/rh/devtoolset-9/root/usr/bin/g++ -std=c++11 -fPIC CXX14=/opt/rh/devtoolset-9/root/usr/bin/g++ -std=c++14 -fPIC 如果没有root权限，可以通过conda来安装新版本的gcc,c++等：
conda install gcc_linux-64 conda install gxx_linux-64  加上conda-forge通道也可以。
 另外可以一键安装常用的编译器：
conda install -c conda-forge compilers 安装完成后记得添加环境变量：
export CC=/path/to/anaconda/bin/x86_64-conda_cos6-linux-gnu-gcc export CXX=/path/to/anaconda/bin/x86_64-conda_cos6-linux-gnu-g++ 如果是R包编译，修改前面提到的Makevars文件即可。
如果使用的是miniconda，这个文件的内容可能就是这样的了：
CXX11=~/miniconda3/bin/x86_64-conda-linux-gnu-g++ -std=c++11 -fPIC CXX14=~/miniconda3/bin/x86_64-conda-linux-gnu-g++ -std=c++14 -fPIC 这样就可以愉快地安装包了：</description>
    </item>
    
    <item>
      <title>Shell：工具工作技巧备忘</title>
      <link>/blog/unix-working-tricks/</link>
      <pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-working-tricks/</guid>
      <description>远程传输和备份文件（夹） 使用scp无法续传，使用rsync更好。
rsync -avLr --progress huaxi:/remote_dir/ ./local_dir 从bed文件指定的区域提取bam结果 samtools view -@ 4 -bhL ../regions_to_check_in_bam.bed /public/home/zhaoxxx.bam &amp;gt; xxx.bam </description>
    </item>
    
    <item>
      <title>Unix：Bash编程</title>
      <link>/blog/unix-bash-programming/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-bash-programming/</guid>
      <description>原文：https://seankross.com/the-unix-workbench/bash-programming.html
 数学 创建math.sh：
#!/usr/bin/env bash # File: math.sh expr 5 + 2 expr 5 - 2 expr 5 \* 2 # 转义 expr 5 / 2 保存然后运行：
$ bash math.sh 7 3 10 2 ⚠️注意，bash使用整除法。求余使用%符号。
如果我们想要进行更为复杂的数学计算，使用bc命令。
创建文件bigmath.sh：
#!/usr/bin/env bash # File: bigmath.sh echo &amp;#34;22 / 7&amp;#34; | bc -l echo &amp;#34;4.2 * 9.15&amp;#34; | bc -l echo &amp;#34;(6.5 / 0.5) + (6 * 2.2)&amp;#34; | bc -l 结果：</description>
    </item>
    
    <item>
      <title>Unix：Make</title>
      <link>/blog/unix-make/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/unix-make/</guid>
      <description>2021/05/26 22:01
 原文：https://seankross.com/the-unix-workbench/working-with-unix.html#make
 从前没有网页浏览器、文件浏览器、开始菜单或搜索栏。当有人启动电脑时，他们得到的是一个shell提示符，他们做的所有工作都是从这个提示符开始的。那时候，人们仍然喜欢共享软件，但总是存在软件应该如何安装的问题。make程序是解决这个问题的最好的尝试，make的优雅使它至今仍被广泛使用。make的指导设计目标是为了安装一些新软件:
  将所有的依赖下载到一个目录。
  cd进入目录。
  运行make。
  这是通过指定一个名为makefile的文件来实现的，该文件描述了不同文件和程序之间的关系 。除了安装程序之外，make对于自动创建文档也很有用。让我们构建一个makefile，它创建一个readme.txt文件，该文件自动填充有关当前目录的一些信息。
首先进入目录并创建一个文件：
▶ cd ~/Documents/test ▶ nano makefile 填入如下内容：
draft_journal_entry.txt: touch draft_journal_entry.txt 上面简单的makefile说明了一个规则，它的一般格式如下：
[target]: [dependencies...] [commands...] 在这个简单的示例中，我们创建了以draft_journal_entry.txt为目标的文件，该文件是作为命令的结果创建的。需要注意的是，目标下的任何命令都必须用Tab缩进。如果我们不使用Tab 来缩进命令，那么make将失败。让我们保存并关闭makefile，然后我们可以在控制台中运行以下命令：
▶ ls makefile 然后使用下面的操作查看make使用方式：
▶ make draft_journal_entry.txt touch draft_journal_entry.txt ▶ ls draft_journal_entry.txt makefile 在我们为draft_journal_entry.txt目标定义的规则下缩进的命令已经执行，所以现在draft_journal_entry.txt存在！让我们再次运行相同的make命令：
▶ make draft_journal_entry.txt make: `draft_journal_entry.txt&amp;#39; is up to date. 因为目标文件已经存在，所以没有采取任何操作，相反，我们被告知，draft_journal_entry.txt的规则是“最新的”(没有什么需要做的)。
如果我们看一下我们之前草拟的一般规则格式，我们可以看到我们没有为该规则指定任何依赖项。依赖项是目标在构建时所依赖的文件。如果自上次为目标运行make以来，依赖项已经更新，则目标不是“最新的”。这意味着下次为该目标运行make时将运行该目标的命令。通过这种方式，对依赖项的更改被合并到目标中。为了避免不必要地运行命令，这些命令只在依赖项改变时运行，或者当目标根本不存在时运行。
让我们更新makefile，以包含自动生成的readme.txt。首先，让我们添加文件：
▶ echo &amp;#34;1. 2017-06-15-In-Boston&amp;#34; &amp;gt; toc.txt makefile修改为：
draft_journal_entry.txt: touch draft_journal_entry.</description>
    </item>
    
  </channel>
</rss>
