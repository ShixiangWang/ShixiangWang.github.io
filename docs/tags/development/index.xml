<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>development on ShixiangWang
(王诗翔)</title>
    <link>/tags/development/</link>
    <description>Recent content in development on ShixiangWang
(王诗翔)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="/tags/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ggplot2在R包开发中的使用</title>
      <link>/blog/ggplot2-in-r-package/</link>
      <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot2-in-r-package/</guid>
      <description>没有特别系统的学习 tidy evaluation 这方面的高级操作，最近有空准备补一补，学习下这方面的知识。
原英文：https://github.com/tidyverse/ggplot2/blob/HEAD/vignettes/ggplot2-in-packages.Rmd
这篇文章是为在包代码中使用ggplot2的包开发人员准备的。在撰写本文时，ggplot2涉及在CRAN上的超过2,000个包和其他地方的更多包！在包中使用ggplot2编程增加了几个约束，特别是如果你想将包提交给CRAN。尤其是在R包中编程改变了从ggplot2引用函数的方式，以及在aes()和vars()中使用ggplot2的非标准求值的方式。
引用ggplot2函数与引用其他包类似，你需要在DESCRIPTION文件下的Imports条目下列出ggplot2，并使用::访问ggplot2提供的函数。（例如， ggplot2::function_name）：
mpg_drv_summary &amp;lt;- function() {ggplot2::ggplot(ggplot2::mpg) + ggplot2::geom_bar(ggplot2::aes(x = .data$drv)) + ggplot2::coord_flip()}如果你经常使用ggplot2，你可能希望将ggplot2的多个函数写入NAMESPACE文件。如果你使用roxygen2，那么你可以利用注释代码块 #&#39; @importFrom ggplot2 &amp;lt;one or more object names&amp;gt; （注意，这对数据集mpg不起作用）。
#&amp;#39; @importFrom ggplot2 ggplot aes geom_bar coord_flipmpg_drv_summary &amp;lt;- function() {ggplot(ggplot2::mpg) + geom_bar(aes(x = drv)) + coord_flip()}即使你的包里使用了很多的ggplot2函数，将ggplot2列入Depends条目或者将它整个导入NAMESPACE（例如，通过#&#39; @import ggplot2）都是不明智的。将ggplot2列入Depends会让你的包在被加载/测试的同时加载ggplot2。这会让其他想要使用你包的人通过::使用你的函数而无需加载它。同样地，导入ggplot2全部450个导出对象到你的命名空间会让分离你的包和ggplot2包的责任变得困难，特别是读者会搞不清这些函数到底来自哪里。
我个人碰到过很多这种情况。有时候在开发R包时为了保证正常运行，不得不将依赖包列入Depdens。实际上，如上所说，这一方面会让使用者懵逼，另一方面会造成开发病毒式感染，既不方便调试错误，想要使用你的包开发的人又不得不将你的包列入Depends。
在包函数中使用 aes() 和 vars()为了使用ggplot2创建图形，你很可能至少要使用一次aes()函数。如果你的图形使用了分面操作，你可能也会使用vars()用来指向绘图数据。而这两个函数都使用了非标准计算，如果你在包中直接使用它，后面再CMD check的使用会引入一个note。</description>
    </item>
    
    <item>
      <title>如何用Julia语言创建软件包</title>
      <link>/blog/julia-packaging/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/julia-packaging/</guid>
      <description>源：https://jaantollander.com/post/how-to-create-software-packages-with-julia-language/
 介绍 本文将教你如何用Julia编程语言创建一个开源的软件包，并使用基于git的工作流开发软件包。例如，你将了解如何自动化单元测试和文档部署，以及发布包的新版本。此外，我们创建了Julia播放列表的逐步视频教程，以指导你通过这个过程。
安装Julia 首先，我们将从julialang网站的下载页面安装Julia编程语言。在Linux中，我们可以将存档解压缩到所需的位置。我们将使用~/software/目录。
~/.bashrc添加配置如下：
export PATH=&amp;#34;$PATH:$HOME/software/julia-1.5.3-linux-x86_64/julia-1.5.3/bin&amp;#34; 上面的版本根据你自己的实际情况进行修改。
Julia REPL  How to use Julia REPL for Developing Packages
 我们可以通过在命令行输入Julia来打开Julia REPL。Julia REPL有四种不同的模式：
 Julia模式julia&amp;gt;用于测试Julia代码。 包管理模式pkg&amp;gt;用于执行包管理命令。可以使用]进行激活。 帮助模式help?&amp;gt;用于打印帮助和文档。我们可以使用?进行激活。 Shell模式shell&amp;gt;用于执行shell命令。我们可以使用分号;进行激活。  我们可以使用回车符从其他模式退回到Julia模式。
包结构 我们的包结构将遵循使用Julia语言创建软件包的官方示例。我们可以在Example.jl中找到示例库。我们可以克隆示例库并对其进行研究。以点开头的目录可能被操作系统隐藏了。我们可以从文件系统设置中显示隐藏的文件。Julia包结构如下所示：
Example/ ├─ .git/ ├─ .github/ │ └─ workflows/ │ ├─ TagBot.yml │ └─ ci.yml ├─ docs/ │ ├─ src/ │ │ └─ index.md │ ├─ Project.toml │ └─ make.jl ├─ src/ │ └─ Example.jl ├─ test/ │ └─ runtests.</description>
    </item>
    
  </channel>
</rss>
