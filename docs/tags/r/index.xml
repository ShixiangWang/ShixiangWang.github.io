<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on ShixiangWang
王诗翔</title>
    <link>/tags/r/</link>
    <description>Recent content in R on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>此mutate非彼mutate</title>
      <link>/blog/this-mutate-is-not-that-mutate/</link>
      <pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/this-mutate-is-not-that-mutate/</guid>
      <description>程序出乎意料，怎么办？
今天在星球圈里收到提问：
我对ddply()这个函数是不熟悉的，只知道hadley一个过时的包plyr里有一系列这样的函数。 所以我首先想到的是这位朋友用错了。不过我马上就排除了，这种问题是非常容易发现和处理的。
因此还是得动手实际检验一下这个问题在我的电脑上是否可以重复。
我们首先把数据导入进来：
library(scales) library(tidyverse) library(plyr) ts &amp;lt;- openxlsx::read.xlsx(&amp;quot;~/Downloads/示例数据.xlsx&amp;quot;) head(ts) ## Name variable value ## 1 SLCO1B1 TCGA-44-2666 3.52916020 ## 2 GCGR TCGA-44-2666 0.08499940 ## 3 HTR3A TCGA-44-2666 0.05029628 ## 4 CA9 TCGA-44-2666 0.19814361 ## 5 TNFSF11 TCGA-44-2666 0.28202803 ## 6 FGB TCGA-44-2666 4.56223499 按照两种不同的方法生成结果：
out1 = ts %&amp;gt;% ddply(., .(variable), transform, rescale = rescale(value)) %&amp;gt;% arrange(variable, Name) head(out1) ## Name variable value rescale ## 1 ADRB2 TCGA-05-4390 2.</description>
    </item>
    
    <item>
      <title>ezcox v1.0.2 更新</title>
      <link>/blog/ezcox-v1-2-update/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/ezcox-v1-2-update/</guid>
      <description>针对@lijing-lin在GitHub的ezcox仓库提出的Fast way to add interaction terms?问题， 这两天闲暇时废了些脑细胞进行解决。同时也fix之前记录的一个遗留问题。
remotes::install_github(&amp;quot;ShixiangWang/ezcox&amp;quot;) 交互项支持 之前为了解决用户数据列名不符合的R命名规则，在源代码例自动对不合法名字进行了反撇号标记。 这会导致R的公式没法进行解析，例如sex:age会被判断为一个列名，R的公式没法解析它，因为 找不到数据中对应的sex:age列，所以会报错。
library(survival) library(ezcox) lung$ph.ecog &amp;lt;- factor(lung$ph.ecog) ezcox(lung, covariates = c(&amp;quot;age&amp;quot;), controls = &amp;quot;sex:ph.ecog&amp;quot;) ## # A tibble: 5 × 12 ## Variable is_control contrast_level ref_level n_contrast n_ref beta HR ## &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; ## 1 age FALSE age NA NA NA 0.00844 1.01 ## 2 age TRUE sex:ph.ecog0 NA NA NA -0.890 0.</description>
    </item>
    
    <item>
      <title>R6编程</title>
      <link>/blog/r6-programming/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/r6-programming/</guid>
      <description>原文来源：https://r6.r-lib.org/articles/Introduction.html
 R6包为R提供了封装的面向对象编程的实现（有时也被称为经典的面向对象编程）。它类似于R的引用类，但它更高效，不依赖于S4类和方法包。
与R中的许多对象不同，R6类的实例(对象)具有引用语义。R6类还支持：
 公共和私有方法 active bindings 跨包工作的继承(超类)  基础 下面是如何创建一个简单的R6类。public参数是一个项目列表，可以是函数和字段(非函数)。函数将被用作方法。
library(R6) Person &amp;lt;- R6Class( &amp;quot;Person&amp;quot;, public = list( name = NULL, hair = NULL, initialize = function(name = NA, hair = nA) { self$name &amp;lt;- name self$hair &amp;lt;- hair self$greet() }, set_hair = function(val) { self$hair &amp;lt;- val }, greet = function() { cat(paste0(&amp;quot;Hello, my name is &amp;quot;, self$name, &amp;quot;.\n&amp;quot;)) } ) ) 使用$new()进行初始化：
ann &amp;lt;- Person$new(&amp;quot;Ann&amp;quot;, &amp;quot;black&amp;quot;) ## Hello, my name is Ann.</description>
    </item>
    
    <item>
      <title>跳过R包check系统使用无法显式载入DESCRIPTION的外部包</title>
      <link>/blog/skip-r-check-system/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/skip-r-check-system/</guid>
      <description>.attach_this &amp;lt;- function() { if (!&amp;#34;ggpubr&amp;#34; %in% (.packages())) { tryCatch(eval(parse(text = &amp;#34;library(ggpubr)&amp;#34;)), error = function(e) { eval(parse(text = &amp;#39;remotes::install_github(&amp;#34;ggpubr&amp;#34;)&amp;#39;)) eval(parse(text = &amp;#34;library(ggpubr)&amp;#34;)) }) } } `%:::%` &amp;lt;- function(pkg, fun, inherits = TRUE) { get(fun, envir = asNamespace(pkg), inherits = inherits ) } .attach_this() ggboxp &amp;lt;- &amp;#34;ggpubr&amp;#34;%:::%&amp;#34;ggboxplot&amp;#34; args(ggboxp) </description>
    </item>
    
    <item>
      <title>rstatix使用fisher检验处理比例关系</title>
      <link>/blog/rstatix-fisher-test/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rstatix-fisher-test/</guid>
      <description>Fisher检验R默认就可以做，但是只支持一次检验，为了更好地处理数据，这篇文章通过rstatix包的相关功能来 学习一些新知识。
library(rstatix)  本文的相关代码文档可以运行?rstatix::fisher_test()查看。
 比较2个比例值 生成数据：
xtab &amp;lt;- as.table(rbind(c(490, 10), c(400, 100))) dimnames(xtab) &amp;lt;- list( group = c(&amp;quot;grp1&amp;quot;, &amp;quot;grp2&amp;quot;), smoker = c(&amp;quot;yes&amp;quot;, &amp;quot;no&amp;quot;) ) xtab ## smoker ## group yes no ## grp1 490 10 ## grp2 400 100 进行比较：
fisher_test(xtab) ## # A tibble: 1 × 3 ## n p p.signif ## * &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; ## 1 1000 8.77e-22 **** # 给出更多的比较信息 fisher_test(xtab, detailed = TRUE) ## # A tibble: 1 × 8 ## n estimate p conf.</description>
    </item>
    
    <item>
      <title>解决igraph使用optimap_函数报错：GLPK is not available, Unimplemented function call</title>
      <link>/blog/fix-igprah-glpk-error/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/fix-igprah-glpk-error/</guid>
      <description>在使用igraph的测试用例时，发生GLPK相关的报错：
&amp;gt; g &amp;lt;- make_graph(&amp;#34;Zachary&amp;#34;) &amp;gt; oc &amp;lt;- cluster_optimal(g) Error in cluster_optimal(g) : At optimal_modularity.c:85 : GLPK is not available, Unimplemented function call GitHub的帖子#273对该问题进行了一些 积极的讨论，不过主要集中在MacOS系统上。而我要解决的是CentOS上的问题。
不过原理相通，加上cluster_optimal函数文档的描述，大体知道了CRAN不允许igraph团队 内置该库，所以从1.2.1版本后就移除了，因此需要安装包之前在相关系统上安装好该库， 这样该包安装的时候就能够编译相应的函数。否则，相应的函数使用就会报错。
一种解决的思路就是安装之前的版本，我尝试了下，发现一些编译报错。可能是旧代码存在一些 bug吧，所以只能用最新版本。
这样需要先用root权限安装库：
yum install glpk glpk-devel 然后再安装：
install.packages(&amp;#34;igraph&amp;#34;) 安装时间会比较长。
如果仔细观察的话，会发现g++的命令中会指定加入-lglpk选项用于加入相关的库进行编译。
g++ -m64 -std=gnu++11 -shared -L/usr/lib64/R/lib -Wl,-z,relro -o igraph.so AMD/Source/amd.o AMD/Source/amd_1.o AMD/Source/amd_2.o AMD/Source/amd_aat.o AMD/Source/amd_control.o AMD/Source/amd_defaults.o AMD/Source/amd_dump.o AMD/Source/amd_global.o AMD/Source/amd_info.o AMD/Source/amd_order.o AMD/Source/amd_post_tree.o AMD/Source/amd_postorder.o AMD/Source/amd_preprocess.o AMD/Source/amd_valid.o AMD/Source/amdbar.o CHOLMOD/Check/cholmod_check.o CHOLMOD/Check/cholmod_read.o CHOLMOD/Check/cholmod_write.o CHOLMOD/Cholesky/cholmod_amd.o CHOLMOD/Cholesky/cholmod_analyze.o CHOLMOD/Cholesky/cholmod_colamd.o CHOLMOD/Cholesky/cholmod_etree.o CHOLMOD/Cholesky/cholmod_factorize.o CHOLMOD/Cholesky/cholmod_postorder.</description>
    </item>
    
    <item>
      <title>处理glm.fit: fitted probabilities numerically 0 or 1 occurred</title>
      <link>/blog/process-glm-logistic-warning/</link>
      <pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/process-glm-logistic-warning/</guid>
      <description>原文：https://www.statology.org/glm-fit-fitted-probabilities-numerically-0-or-1-occurred/
 在建立逻辑回归模型时遇到这个警告：
Warning message: glm.fit: fitted probabilities numerically 0 or 1 occurred 当拟合逻辑回归模型，且数据框中一个或多个观测值的预测概率与0或1难以区分时，会出现此警告。
值得注意的是，这是一个警告消息，而不是一个错误。即使你收到这个错误，你的逻辑回归模型仍然是合适的，但是可能值得分析原始数据框，看看是否有任何异常值导致此警告消息出现。
本教程将分享如何在实践中处理此警告消息。
重复警告 假设我们将logistic回归模型拟合到R中的以下数据框：
#create data frame df &amp;lt;- data.frame(y = c(0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1), x1 = c(3, 3, 4, 4, 3, 2, 5, 8, 9, 9, 9, 8, 9, 9, 9), x2 = c(8, 7, 7, 6, 5, 6, 5, 2, 2, 3, 4, 3, 7, 4, 4)) #fit logistic regression model model &amp;lt;- glm(y ~ x1 + x2, data=df, family=binomial) #view model summary summary(model) Warning message: glm.</description>
    </item>
    
    <item>
      <title>Rcpp：什么时候使用Rcpp</title>
      <link>/blog/when-use-rcpp/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/when-use-rcpp/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/010_Rcpp_merit.html
什么时候使用  后面的迭代依赖于前面的迭代的循环操作。 需要访问向量/矩阵的每个元素。 在循环中循环调用函数。 动态更改向量的大小。 需要高级数据结构和算法的操作。  怎么配置 除了Windows需要安装Rtools，其他系统中一般已经装好了。
如果我们要自定义C++的配置，如更改编译器，需要使用到配置文件.R/Makevars。
下面是一个示例：
CC=/opt/local/bin/gcc-mp-4.7 CXX=/opt/local/bin/g++-mp-4.7 CPLUS_INCLUDE_PATH=/opt/local/include:$CPLUS_INCLUDE_PATH LD_LIBRARY_PATH=/opt/local/lib:$LD_LIBRARY_PATH CXXFLAGS= -g0 -O2 -Wall MAKE=make -j4  包括编译器位置、头文件位置、动态库位置、编译参数等。
 安装Rcpp install.packages(&amp;#34;Rcpp&amp;#34;) </description>
    </item>
    
    <item>
      <title>Rcpp：基本用法</title>
      <link>/blog/rcpp-basic-usage/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-basic-usage/</guid>
      <description>来源：https://teuder.github.io/rcpp4everyone_en/030_basic_usage.html
使用Rcpp函数只需要3步：
 编写Rcpp源代码。 编译代码。 执行函数。  编写Rcpp代码 下面是一个对向量求和的Rcpp函数：
//sum.cpp #include &amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&amp;lt;v.length(); ++i){ sum += v[i]; } return(sum); } Rcpp函数定义格式 下面是定义一个Rcpp函数的基本格式：
#include&amp;lt;Rcpp.h&amp;gt;using namespace Rcpp; // [[Rcpp::export]] RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){ //do something  return RETURN_VALUE; }  #include&amp;lt;Rcpp.h&amp;gt;：这个句子允许你使用Rcpp包定义的类和函数。 // [[Rcpp::export]]：这个句子下面定义的函数可以从R中访问。 你需要把这个句子附加到你想从R中使用的每个函数中。 using namespace Rcpp;：这个句子是可选的。但是如果你没有写这个句子， 你必须添加前缀Rcpp::来指定由Rcpp定义的类和函数。(例如：Rcpp::NumericVector) RETURN_TYPE FUNCTION_NAME(ARGUMENT_TYPE ARGUMENT){}：你需要指定函数和参数的数据类型。 return RETURN_VALUE;：如果函数将返回一个值，return语句是强制性的。 然而，如果你的函数没有返回值（即RETURN_TYPE是无效的），返回语句可以省略。  编译代码 函数Rcpp::sourceCpp()将编译你的源代码，并将定义的函数加载到R。
library(Rcpp) sourceCpp(&amp;#39;sum.cpp&amp;#39;) 使用函数 像正常R函数一样调用它就可以了。</description>
    </item>
    
    <item>
      <title>mlr3（三）模型优化</title>
      <link>/blog/mlr3-model-optimization/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-model-optimization/</guid>
      <description>来源：https://mlr3book.mlr-org.com/optimization.html
模型优化
机器学习算法为其超参数设置了默认值。不管怎样，用户需要更改这些超参数，以在给定的数据集上实现最佳性能。不建议手动选择超参数值，因为这种方法很少能获得最佳性能。为了证实所选超参数（=调优）的有效性，建议进行数据驱动的优化。为了优化机器学习算法，必须指定（1）搜索空间，（2）优化算法(又称调优方法)，（3）评估方法，即重采样策略，（4）性能度量。
总而言之，关于调优的小节介绍：
 进行经验超参数选择 选择优化算法 简洁地指定搜索空间 触发调优 自动调优  本小节还需要包mlr3tuning，这是一个支持超参数调优的扩展包。
特征选择
本章的第二部分介绍特征选择，也称为变量选择。特征选择是寻找数据相关特征子集的过程。执行选择的一些原因：
 增强模型的可解释性 加速模型拟合 通过降低数据中的噪声来提高学习性能  在本文中，我们主要集中在最后一个方面。有不同的方法来识别相关的特征。在特征选择的分章中，我们强调了三种方法：
 运用过滤算法根据分数独立地选择特征 根据变量重要性过滤选择特征 包装器方法迭代地选择特性以优化性能度量  注意，过滤器不需要学习器。变量重要性过滤器需要一个学习器，该学习器在训练时可以计算特征的重要性值。获得的重要值可用于数据子集，然后可用于训练学习器。包装器方法可以用于任何学习器，但需要对学习器进行多次训练。
嵌套重采样
为了更好地估计泛化性能并避免数据泄漏，外部（性能）和内部（调优/特征选择）重采样过程都是必要的。本章将讨论以下特点：
 嵌套重采样中的内重采样和外重采样策略 嵌套重采样的执行 执行重采样迭代的评估  本小节将提供如何实现嵌套重采样的说明，包括mlr3中的内重采样和外重采样。
超参数调优 超参数是机器学习模型的二阶参数，虽然在模型估计过程中往往没有明确优化，但会对模型的结果和预测性能产生重要影响。通常，超参数在训练模型之前是固定的。但是，由于模型的输出可能对超参数的规范很敏感，因此通常建议对哪些超参数设置可以产生更好的模型性能做出明智的决定。在许多情况下，超参数设置可能是预先选择的，但在将模型拟合到训练数据上之前，尝试不同的设置可能是有利的。这个过程通常被称为模型“调优”。
超参数调优是通过mlr3tuning扩展包支持的。下面是这个过程的说明：
mlr3tuning的核心是R6类：
TuningInstanceSingleCrit，TuningInstanceMultiCrit：这两个类描述调优问题并存储结果。
Tuner：这个类是调优算法实现的基类。
TuningInstance* 类 下面的小节审查了皮马印度糖尿病数据集上的简单分类树的优化。
library(&amp;quot;mlr3verse&amp;quot;) task = tsk(&amp;quot;pima&amp;quot;) print(task) ## &amp;lt;TaskClassif:pima&amp;gt; (768 x 9) ## * Target: diabetes ## * Properties: twoclass ## * Features (8): ## - dbl (8): age, glucose, insulin, mass, pedigree, pregnant, pressure, ## triceps 我们使用rpart中的分类树，并选择我们想要调优的超参数的子集。这通常被称为“调优空间”。</description>
    </item>
    
  </channel>
</rss>
