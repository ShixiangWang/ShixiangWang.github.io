<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on ShixiangWang
王诗翔</title>
    <link>/tags/r/</link>
    <description>Recent content in R on ShixiangWang
王诗翔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>R小技巧：分组应用和排序去重的应用与比较</title>
      <link>/blog/r-tricks-remove-duplicates-after-ordering/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/r-tricks-remove-duplicates-after-ordering/</guid>
      <description>问题与方案 假设我们有这样一个数据集：
df &amp;lt;- data.frame( c1 = c(&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;), c2 = c(1, 3, 2, 1, 4, 2) ) df out c1 c2 out 1 a 1 out 2 a 3 out 3 a 2 out 4 b 1 out 5 b 4 out 6 c 2 如果我们想保留每个c1分类和分类下的最大值，你会怎么操作？
思考一分钟。
如果使用惯了tidyverse套装，我们脑子里容易冒出来的是这样的解法：使用分组应用。
library(dplyr) df |&amp;gt; group_by(c1) |&amp;gt; summarize(c2 = max(c2, na.rm = TRUE)) out # A tibble: 3 × 2 out c1 c2 out &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; out 1 a 3 out 2 b 4 out 3 c 2 在数据不是特别大的时候，使用这种策略没有任何问题。但如果分组有成千上万，分组的时间代价就很高了。有没有其他的方式可以解决该问题呢？</description>
    </item>
    
    <item>
      <title>forestmodel给多水平变量添加整体p值</title>
      <link>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/forestmode-set-overall-pva-for-variable-with-multiple-levels/</guid>
      <description>前段时间收到来信：
1Hi Shixiang 2 3I am writing to you about the forestmodel package in R. 4 5Thank you so much for the wonderful package that you created. 6 7I was wondering if there is a way to display the wald test p-value which is important for variables that have more than two levels. I tried to work around the code but did not find a way out. 8 9Best 10Aniket 我不是作者，搞错了人，问我干啥呢～自个提问嘛</description>
    </item>
    
    <item>
      <title>mlr3（一）快速入门</title>
      <link>/blog/mlr3-quickstart/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/mlr3-quickstart/</guid>
      <description>来源：https://mlr3book.mlr-org.com/quickstart.html
安装包：
install.packages(&amp;quot;mlr3&amp;quot;) 作为一个30秒的介绍性示例，我们将在虹膜数据集的前120行训练决策树模型，并对最后30行进行预测，测量训练模型的准确性。
library(&amp;quot;mlr3&amp;quot;) task = tsk(&amp;quot;iris&amp;quot;) learner = lrn(&amp;quot;classif.rpart&amp;quot;) # 为任务的一个子集（前120行）训练这个学习者的模型 learner$train(task, row_ids = 1:120) # 决策树模型 learner$model out n= 120 out out node), split, n, loss, yval, (yprob) out * denotes terminal node out out 1) root 120 70 setosa (0.41666667 0.41666667 0.16666667) out 2) Petal.Length&amp;lt; 2.45 50 0 setosa (1.00000000 0.00000000 0.00000000) * out 3) Petal.Length&amp;gt;=2.45 70 20 versicolor (0.00000000 0.71428571 0.28571429) out 6) Petal.</description>
    </item>
    
    <item>
      <title>PR曲线与AUC</title>
      <link>/blog/pr-curve-and-auc-value/</link>
      <pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/pr-curve-and-auc-value/</guid>
      <description>这里直接使用ROCR包提供的数据作为示例：
library(ROCR) data(ROCR.simple) pred &amp;lt;- prediction(ROCR.simple$predictions, ROCR.simple$labels) perf &amp;lt;- performance(pred,&amp;quot;tpr&amp;quot;,&amp;quot;fpr&amp;quot;) plot(perf) ## precision/recall curve (x-axis: recall, y-axis: precision) perf1 &amp;lt;- performance(pred, &amp;quot;prec&amp;quot;, &amp;quot;rec&amp;quot;) plot(perf1, xlim = c(0, 1), ylim = c(0, 1)) 使用 PRROC 包获取PR AUC值并且绘图：
pr &amp;lt;- PRROC::pr.curve(ROCR.simple$predictions, weights.class0 = ROCR.simple$labels, curve = TRUE) pr ## ## Precision-recall curve ## ## Area under curve (Integral): ## 0.7815038 ## ## Area under curve (Davis &amp;amp; Goadrich): ## 0.7814246 ## ## Curve for scores from 0.</description>
    </item>
    
    <item>
      <title>《R语言数据科学导论》笔记</title>
      <link>/blog/note-for-r-data-science-intro/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/note-for-r-data-science-intro/</guid>
      <description>原始资料来源：https://github.com/leovan/data-science-introduction-with-r
特征工程 特征工程是将原始数据转换成特征的过程。更通俗地说，特征工程就是人工设计模型的输入变量 x的过程。
主要分为：
 数据预处理 特征提取和选择 特征变换和编码 特征监控  数据预处理 对赃数据进行清洗，包括括缺失，噪声，不一致等等一系列问题数据。
剔除处理：
 样本去重。同一个ID出现多次重复记录。 特征去重。例如月收入和年收入，它们都是用于表征收入特征，关系只差常数倍。 常量特征剔除。即常量或方差近似为0的特征。caret包中的nearZeroVar()可以帮助我们识别该类特征。  缺失值处理：
 探索缺失值：mice包的md.pattern()，VIM包的aggr()/marginplot()。 处理：  删除法，可以直接使用na.omit()。 插补法，如果该特征对最终的预测结果影响较小，则我们可以直接删除该特征；相反如果该特征对预测结果影响较大，直接删除会对模型造成较大的影 响，此时我们需要利用其它的方法对该特征的缺失值进行填补。其中最简单的方式是利用均值，中位数或众数等统计量对其进行简单插补。这种插补方法是建立在完全随机缺失的前提假设下，同时会造成变量方差变小。    异常值是指样本中存在的同样本整体差异较大的数据。
分为2类：
采样是一种常见的预处理技术。
 随机采样。每个样本单位被抽中的概率相等，样本的每个单位完全独立，彼此间无一定的关联性和排斥性。 分层采样。将抽样单位按某种特征或某种规则划分为不同的层，然后从不同的层中独立、随机地抽取样本。从而保证样本的结构与总体的结构比较相近，从而提高估计的精度。可以利用sampling::strata()。 欠采样和过采样。我们经常会碰到不同分类的样本比例相差较大的问题，这种问题会对我们构建模型造成很大的影响，因此从数据角度出发，我们可以利用欠采样或过采样处理这种现象。可以利用ROSE::ovun.sample()。  特征变换和编码 无量纲化 通过归一化，我们可以消除不同量纲下的数据对最终结果的影响。
1normalize &amp;lt;- function(x) { 2 # 计算极值 3 x_min &amp;lt;- min(x) 4 x_max &amp;lt;- max(x) 5 # 归一化 6 x_n &amp;lt;- (x - x_min) / 7 (x_max - x_min) 8 # 将极值作为结果的属性 9 attr(x_n, 10 &amp;#39;min&amp;#39;) &amp;lt;- x_min 11 attr(x_n, 12 &amp;#39;max&amp;#39;) &amp;lt;- x_max 13 # 返回归一化后结果 14 x_n 15} 标准化。</description>
    </item>
    
    <item>
      <title>解决由于网络问题导致的stringi安装失败问题</title>
      <link>/blog/install-stringi-when-bad-acess-to-gh/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/install-stringi-when-bad-acess-to-gh/</guid>
      <description>这是一个我每次重装R，或者在新的系统上使用R进行包安装，都会遇到的问题。
stringi是tidyverse的一个核心包，基本上必装。但由于gayhub经常访问有问题，这个包安装时所需要的依赖文件会下载不了。 解决的办法是手动下载，然后进行安装：
1wget https://github.com/gagolews/stringi/archive/master.zip -O stringi.zip 2# 如果上面github的链接无法下载，尝试： 3# wget https://download.fastgit.org/gagolews/stringi/archive/master.zip -O stringi.zip 4unzip stringi.zip 5sed -i &amp;#39;/\/icu..\/data/d&amp;#39; stringi-master/.Rbuildignore 6R CMD build stringi-master 7R CMD INSTALL stringi*.tar.gz 参考：https://stackoverflow.com/questions/31942322/how-to-install-stringi-from-local-file-absolutely-no-internet-access#</description>
    </item>
    
    <item>
      <title>使用modules包来组织R的函数集合</title>
      <link>/blog/use-modules-to-organize-r-functions/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/use-modules-to-organize-r-functions/</guid>
      <description>接触过Python的朋友肯定对模块很熟悉，R的代码组织方式以包为主。但基于文件的模块形式也是可以实现的，modules 包提供了这种支持。
安装和使用 直接从CRAN下载即可：
1install.packages(&amp;#34;modules&amp;#34;) 使用了解2个函数的使用就可以了。
一是import()，用于替换library()加载包。
1&amp;gt; library(modules) 2&amp;gt; gp = import(&amp;#39;ggplot2&amp;#39;) 3Masking (modules:ggplot2): 4 `Position` from: base 5&amp;gt; args(gp$ggplot) 6function (data = NULL, mapping = aes(), ..., environment = parent.frame()) 7NULL 8&amp;gt; args(ggplot) 9function (data = NULL, mapping = aes(), ..., environment = parent.frame()) 10NULL 这样我们可以直接使用这个函数，也可以通过gp这个对象去访问可用的函数。
如果不想要在全局直接访问包内的函数，在导入时设定attach=FALSE。
1&amp;gt; dp &amp;lt;- import(dplyr, attach = FALSE) 2Masking (modules:dplyr): 3 `intersect` from: base 4 `setdiff` from: base 5 `setequal` from: base 6 `union` from: base 7&amp;gt; select 8错误: 找不到对象&amp;#39;select&amp;#39; 9&amp;gt; dp$select 10function (.</description>
    </item>
    
    <item>
      <title>关于区间突变概率计算理解的纠正</title>
      <link>/blog/adjustment-for-mutaiton-prob-in-a-region/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/adjustment-for-mutaiton-prob-in-a-region/</guid>
      <description>资料来源：https://www.huber.embl.de/msmb/Chap-Generative.html，我把资料中的情景更改了下。
 假设50个样本有100个碱基，单个位点有百分之一的突变率，汇总50个样本，我们期望在任何给定位置，50个样本观测到突变次数的总和服从具有参数为0.5的泊松分布。
一个随机的图如下：
现在让我们假设实际观测的图如下：
这种情况的概率是多少呢？
让我们先看一下至少出现7次的概率： $$ \begin{equation*} P(X\geq 7)= \sum_{k=7}^\infty P(X=k). \end{equation*} $$ 它可以转变为1减去出现少于7次的概率。
在R里面可以计算：
我们假设我们最后要计算得到的概率为$\epsilon$： $$ \begin{equation*} \epsilon=P(X\geq 7)=1-P(X\leq 6)\simeq10^{-6}. \end{equation*} $$
停！上面是错误的计算！
上面我们看了100个位置，寻找最大值并发现它是7，这种情况下出现7的概率比单个位置出现7的概率要大！
这里我们使用极端值分析，先对每个位置出现的次数排序，然后重新命名。
那么最大值出现至少7次的概率可以采用互补计算： $$ \begin{equation*} \begin{aligned} P(x_{(100)}\geq 7) &amp;amp;=&amp;amp;1-P(x_{(100)} \leq 6)\\
&amp;amp;=&amp;amp;1-P(x_{(1)}\leq 6 )\times P(x_{(2)}\leq 6 )\times \cdots \times P(x_{(100)} \leq 6 )\\
&amp;amp;=&amp;amp;1-P(x_1\leq 6 )\times P(x_2\leq 6 )\times \cdots \times P(x_{100}\leq 6 )\\
&amp;amp;=&amp;amp;1-\prod_{i=1}^{100} P(x_i \leq 6 ).\end{aligned} \end{equation*} $$ 由于100个事件是独立的，所以转换为： $$ \begin{equation*} \prod_{i=1}^{100} P(x_i \leq 6)= \left(P(x_i \leq 6)\right)^{100}= \left(1-\epsilon\right)^{100}.</description>
    </item>
    
    <item>
      <title>ggplot构建新图形元素</title>
      <link>/blog/ggplot-build-new-object/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/ggplot-build-new-object/</guid>
      <description>2021/05/24 19:35
 原文：https://bookdown.org/rdpeng/RProgDA/building-new-graphical-elements.html
 由ggplot构造的数据图中的关键元素包括geoms（几何对象）和stats（统计变换）。事实上，ggplot2包具有强大的功能，允许用户制作各种有趣而丰富的数据图形。这些图形可以通过组合调用各种geom_*和stat_*函数(以及其他类函数)来实现。
为什么要构造新的图形元素？
  实现ggplot2目前不存在的特性。
  简化复杂的工作流。如果你总是发现自己在用重复的代码绘制类似的图形元素。
  创建新的geoms和stats可以简化代码，让用户轻松调整情节的某些元素，而不必每次都费劲地处理整个代码。
构造一个geom ggplot2中的新geoms继承自一个名为Geom的顶级类，并使用两步流程构造：
  ggproto()函数用于构造一个与新的geom对应的新类。这个新类指定了许多属性和函数，这些属性和函数描述了如何在图上绘制数据。
  geom_*函数被构造为标准函数。这个函数返回一个层，该层可以添加到使用ggplot()函数创建的plot中。
  新的geom类的基本设置如下所示：
1GeomNEW &amp;lt;- ggproto(&amp;#34;GeomNEW&amp;#34;, Geom, 2 required_aes = &amp;lt;a character vector of required aesthetics&amp;gt;, 3 default_aes = aes(&amp;lt;default values for certain aesthetics&amp;gt;), 4 draw_key = &amp;lt;a function used to draw the key in the legend&amp;gt;, 5 draw_panel = function(data, panel_scales, coord) { 6 ## 返回一个grid grob对象的函数 7 ## 是绘图真正工作的地方 8 } 9) 所需的美学映射应该很简单——例如，如果你的新geom生成了一种特殊的散点图，那么你可能需要x和y映射。美学映射的默认值可以包括绘图符号如形状、颜色等内容。</description>
    </item>
    
    <item>
      <title>Rcpp：数据结构</title>
      <link>/blog/rcpp-data-structure/</link>
      <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>/blog/rcpp-data-structure/</guid>
      <description>RObject类 RObject类在Rcpp类系统中占核心地位。虽然它不是面向用户的，但为接下来的所有类提供了公共的数据结构，它是构建Rcpp API的基础类。
每一个RObject类实例都封装了一个R对象，而每个对象在内部可以表示为一个SEXP：一个指向S表达式对象的指针。
基于它的用户可见（可使用）的类：
  IntegerVector对应整型向量。
  NumericVector对应数值向量。
  LogicalVector对应逻辑值向量。
  CharacterVector对应Character向量。
  GenericVector对应List类型的泛型向量。
  ExpressionVector对应表达式类型向量。
  RawVector对应raw类型向量。
  对于整型和数值型，我们还有IntegerMatrix和NumericMatrix对应R中的数值矩阵。
下面我们通过整型向量来了解它们。
IntegerVector类 模板函数as&amp;lt;&amp;gt;()用于从R转换到C++，而wrap()函数的方向相反。
 实际大多数使用情况下，我们已经不需要显式地进行转换处理，该过程会在底层自动完成。
 示例：返回完美数 什么是完美数：
https://baike.baidu.com/item/完全数/370913?fromtitle=完美数&amp;amp;fromid=871560&amp;amp;fr=aladdin
代码：
1library(Rcpp) 2library(inline) 3 4src &amp;lt;- &amp;#39; 5Rcpp::IntegerVector epn(4); 6epn[0] = 6; 7epn[1] = 14; 8epn[2] = 496; 9epn[3] = 8182; 10return epn; 11&amp;#39; 12 13func &amp;lt;- cxxfunction(signature(), src, plugin = &amp;#34;Rcpp&amp;#34;) 调用：</description>
    </item>
    
  </channel>
</rss>
